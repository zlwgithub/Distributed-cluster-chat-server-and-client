// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qq.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_qq_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_qq_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_qq_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_qq_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_qq_2eproto;
namespace fixbug {
class AddFriendRequest;
struct AddFriendRequestDefaultTypeInternal;
extern AddFriendRequestDefaultTypeInternal _AddFriendRequest_default_instance_;
class AddFriendResponse;
struct AddFriendResponseDefaultTypeInternal;
extern AddFriendResponseDefaultTypeInternal _AddFriendResponse_default_instance_;
class AddGroupRequest;
struct AddGroupRequestDefaultTypeInternal;
extern AddGroupRequestDefaultTypeInternal _AddGroupRequest_default_instance_;
class AddGroupResponse;
struct AddGroupResponseDefaultTypeInternal;
extern AddGroupResponseDefaultTypeInternal _AddGroupResponse_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class CreateGroupRequest;
struct CreateGroupRequestDefaultTypeInternal;
extern CreateGroupRequestDefaultTypeInternal _CreateGroupRequest_default_instance_;
class CreateGroupResponse;
struct CreateGroupResponseDefaultTypeInternal;
extern CreateGroupResponseDefaultTypeInternal _CreateGroupResponse_default_instance_;
class FriendList;
struct FriendListDefaultTypeInternal;
extern FriendListDefaultTypeInternal _FriendList_default_instance_;
class GetFriendListRequest;
struct GetFriendListRequestDefaultTypeInternal;
extern GetFriendListRequestDefaultTypeInternal _GetFriendListRequest_default_instance_;
class GetFriendListResponse;
struct GetFriendListResponseDefaultTypeInternal;
extern GetFriendListResponseDefaultTypeInternal _GetFriendListResponse_default_instance_;
class GetGroupListRequest;
struct GetGroupListRequestDefaultTypeInternal;
extern GetGroupListRequestDefaultTypeInternal _GetGroupListRequest_default_instance_;
class GetGroupListResponse;
struct GetGroupListResponseDefaultTypeInternal;
extern GetGroupListResponseDefaultTypeInternal _GetGroupListResponse_default_instance_;
class GetOfflineMsgRequest;
struct GetOfflineMsgRequestDefaultTypeInternal;
extern GetOfflineMsgRequestDefaultTypeInternal _GetOfflineMsgRequest_default_instance_;
class GetOfflineMsgResponse;
struct GetOfflineMsgResponseDefaultTypeInternal;
extern GetOfflineMsgResponseDefaultTypeInternal _GetOfflineMsgResponse_default_instance_;
class Group;
struct GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class GroupChatRequest;
struct GroupChatRequestDefaultTypeInternal;
extern GroupChatRequestDefaultTypeInternal _GroupChatRequest_default_instance_;
class GroupChatResponse;
struct GroupChatResponseDefaultTypeInternal;
extern GroupChatResponseDefaultTypeInternal _GroupChatResponse_default_instance_;
class GroupList;
struct GroupListDefaultTypeInternal;
extern GroupListDefaultTypeInternal _GroupList_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class LoginoutRequest;
struct LoginoutRequestDefaultTypeInternal;
extern LoginoutRequestDefaultTypeInternal _LoginoutRequest_default_instance_;
class LoginoutResponse;
struct LoginoutResponseDefaultTypeInternal;
extern LoginoutResponseDefaultTypeInternal _LoginoutResponse_default_instance_;
class OneChatRequest;
struct OneChatRequestDefaultTypeInternal;
extern OneChatRequestDefaultTypeInternal _OneChatRequest_default_instance_;
class OneChatResponse;
struct OneChatResponseDefaultTypeInternal;
extern OneChatResponseDefaultTypeInternal _OneChatResponse_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class RequestResult;
struct RequestResultDefaultTypeInternal;
extern RequestResultDefaultTypeInternal _RequestResult_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class protobuffer;
struct protobufferDefaultTypeInternal;
extern protobufferDefaultTypeInternal _protobuffer_default_instance_;
}  // namespace fixbug
PROTOBUF_NAMESPACE_OPEN
template<> ::fixbug::AddFriendRequest* Arena::CreateMaybeMessage<::fixbug::AddFriendRequest>(Arena*);
template<> ::fixbug::AddFriendResponse* Arena::CreateMaybeMessage<::fixbug::AddFriendResponse>(Arena*);
template<> ::fixbug::AddGroupRequest* Arena::CreateMaybeMessage<::fixbug::AddGroupRequest>(Arena*);
template<> ::fixbug::AddGroupResponse* Arena::CreateMaybeMessage<::fixbug::AddGroupResponse>(Arena*);
template<> ::fixbug::ChatMessage* Arena::CreateMaybeMessage<::fixbug::ChatMessage>(Arena*);
template<> ::fixbug::CreateGroupRequest* Arena::CreateMaybeMessage<::fixbug::CreateGroupRequest>(Arena*);
template<> ::fixbug::CreateGroupResponse* Arena::CreateMaybeMessage<::fixbug::CreateGroupResponse>(Arena*);
template<> ::fixbug::FriendList* Arena::CreateMaybeMessage<::fixbug::FriendList>(Arena*);
template<> ::fixbug::GetFriendListRequest* Arena::CreateMaybeMessage<::fixbug::GetFriendListRequest>(Arena*);
template<> ::fixbug::GetFriendListResponse* Arena::CreateMaybeMessage<::fixbug::GetFriendListResponse>(Arena*);
template<> ::fixbug::GetGroupListRequest* Arena::CreateMaybeMessage<::fixbug::GetGroupListRequest>(Arena*);
template<> ::fixbug::GetGroupListResponse* Arena::CreateMaybeMessage<::fixbug::GetGroupListResponse>(Arena*);
template<> ::fixbug::GetOfflineMsgRequest* Arena::CreateMaybeMessage<::fixbug::GetOfflineMsgRequest>(Arena*);
template<> ::fixbug::GetOfflineMsgResponse* Arena::CreateMaybeMessage<::fixbug::GetOfflineMsgResponse>(Arena*);
template<> ::fixbug::Group* Arena::CreateMaybeMessage<::fixbug::Group>(Arena*);
template<> ::fixbug::GroupChatRequest* Arena::CreateMaybeMessage<::fixbug::GroupChatRequest>(Arena*);
template<> ::fixbug::GroupChatResponse* Arena::CreateMaybeMessage<::fixbug::GroupChatResponse>(Arena*);
template<> ::fixbug::GroupList* Arena::CreateMaybeMessage<::fixbug::GroupList>(Arena*);
template<> ::fixbug::LoginRequest* Arena::CreateMaybeMessage<::fixbug::LoginRequest>(Arena*);
template<> ::fixbug::LoginResponse* Arena::CreateMaybeMessage<::fixbug::LoginResponse>(Arena*);
template<> ::fixbug::LoginoutRequest* Arena::CreateMaybeMessage<::fixbug::LoginoutRequest>(Arena*);
template<> ::fixbug::LoginoutResponse* Arena::CreateMaybeMessage<::fixbug::LoginoutResponse>(Arena*);
template<> ::fixbug::OneChatRequest* Arena::CreateMaybeMessage<::fixbug::OneChatRequest>(Arena*);
template<> ::fixbug::OneChatResponse* Arena::CreateMaybeMessage<::fixbug::OneChatResponse>(Arena*);
template<> ::fixbug::RegisterRequest* Arena::CreateMaybeMessage<::fixbug::RegisterRequest>(Arena*);
template<> ::fixbug::RegisterResponse* Arena::CreateMaybeMessage<::fixbug::RegisterResponse>(Arena*);
template<> ::fixbug::RequestResult* Arena::CreateMaybeMessage<::fixbug::RequestResult>(Arena*);
template<> ::fixbug::User* Arena::CreateMaybeMessage<::fixbug::User>(Arena*);
template<> ::fixbug::protobuffer* Arena::CreateMaybeMessage<::fixbug::protobuffer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace fixbug {

// ===================================================================

class RequestResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.RequestResult) */ {
 public:
  inline RequestResult() : RequestResult(nullptr) {}
  ~RequestResult() override;
  explicit constexpr RequestResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestResult(const RequestResult& from);
  RequestResult(RequestResult&& from) noexcept
    : RequestResult() {
    *this = ::std::move(from);
  }

  inline RequestResult& operator=(const RequestResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestResult& operator=(RequestResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestResult* internal_default_instance() {
    return reinterpret_cast<const RequestResult*>(
               &_RequestResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RequestResult& a, RequestResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.RequestResult";
  }
  protected:
  explicit RequestResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrmsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // bytes errmsg = 2;
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_NODISCARD std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fixbug.RequestResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit constexpr User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kUserstateFieldNumber = 3,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // bytes userstate = 3;
  void clear_userstate();
  const std::string& userstate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userstate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userstate();
  PROTOBUF_NODISCARD std::string* release_userstate();
  void set_allocated_userstate(std::string* userstate);
  private:
  const std::string& _internal_userstate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userstate(const std::string& value);
  std::string* _internal_mutable_userstate();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userstate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class FriendList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.FriendList) */ {
 public:
  inline FriendList() : FriendList(nullptr) {}
  ~FriendList() override;
  explicit constexpr FriendList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendList(const FriendList& from);
  FriendList(FriendList&& from) noexcept
    : FriendList() {
    *this = ::std::move(from);
  }

  inline FriendList& operator=(const FriendList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendList& operator=(FriendList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendList* internal_default_instance() {
    return reinterpret_cast<const FriendList*>(
               &_FriendList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FriendList& a, FriendList& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FriendList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.FriendList";
  }
  protected:
  explicit FriendList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendFieldNumber = 1,
  };
  // repeated .fixbug.User friend = 1;
  int friend__size() const;
  private:
  int _internal_friend__size() const;
  public:
  void clear_friend_();
  ::fixbug::User* mutable_friend_(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User >*
      mutable_friend_();
  private:
  const ::fixbug::User& _internal_friend_(int index) const;
  ::fixbug::User* _internal_add_friend_();
  public:
  const ::fixbug::User& friend_(int index) const;
  ::fixbug::User* add_friend_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User >&
      friend_() const;

  // @@protoc_insertion_point(class_scope:fixbug.FriendList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User > friend__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class Group final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.Group) */ {
 public:
  inline Group() : Group(nullptr) {}
  ~Group() override;
  explicit constexpr Group(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Group(const Group& from);
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  inline Group& operator=(Group&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Group& default_instance() {
    return *internal_default_instance();
  }
  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }
  inline void Swap(Group* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Group* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Group* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Group>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Group& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Group& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Group* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.Group";
  }
  protected:
  explicit Group(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupmemberFieldNumber = 4,
    kMemberidentityFieldNumber = 5,
    kGroupidFieldNumber = 1,
    kGroupnameFieldNumber = 2,
    kGroupdescFieldNumber = 3,
  };
  // repeated .fixbug.User groupmember = 4;
  int groupmember_size() const;
  private:
  int _internal_groupmember_size() const;
  public:
  void clear_groupmember();
  ::fixbug::User* mutable_groupmember(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User >*
      mutable_groupmember();
  private:
  const ::fixbug::User& _internal_groupmember(int index) const;
  ::fixbug::User* _internal_add_groupmember();
  public:
  const ::fixbug::User& groupmember(int index) const;
  ::fixbug::User* add_groupmember();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User >&
      groupmember() const;

  // repeated bytes memberidentity = 5;
  int memberidentity_size() const;
  private:
  int _internal_memberidentity_size() const;
  public:
  void clear_memberidentity();
  const std::string& memberidentity(int index) const;
  std::string* mutable_memberidentity(int index);
  void set_memberidentity(int index, const std::string& value);
  void set_memberidentity(int index, std::string&& value);
  void set_memberidentity(int index, const char* value);
  void set_memberidentity(int index, const void* value, size_t size);
  std::string* add_memberidentity();
  void add_memberidentity(const std::string& value);
  void add_memberidentity(std::string&& value);
  void add_memberidentity(const char* value);
  void add_memberidentity(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& memberidentity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_memberidentity();
  private:
  const std::string& _internal_memberidentity(int index) const;
  std::string* _internal_add_memberidentity();
  public:

  // bytes groupid = 1;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // bytes groupname = 2;
  void clear_groupname();
  const std::string& groupname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupname();
  PROTOBUF_NODISCARD std::string* release_groupname();
  void set_allocated_groupname(std::string* groupname);
  private:
  const std::string& _internal_groupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupname(const std::string& value);
  std::string* _internal_mutable_groupname();
  public:

  // bytes groupdesc = 3;
  void clear_groupdesc();
  const std::string& groupdesc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupdesc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupdesc();
  PROTOBUF_NODISCARD std::string* release_groupdesc();
  void set_allocated_groupdesc(std::string* groupdesc);
  private:
  const std::string& _internal_groupdesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupdesc(const std::string& value);
  std::string* _internal_mutable_groupdesc();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.Group)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User > groupmember_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> memberidentity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupdesc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class GroupList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.GroupList) */ {
 public:
  inline GroupList() : GroupList(nullptr) {}
  ~GroupList() override;
  explicit constexpr GroupList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupList(const GroupList& from);
  GroupList(GroupList&& from) noexcept
    : GroupList() {
    *this = ::std::move(from);
  }

  inline GroupList& operator=(const GroupList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupList& operator=(GroupList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupList* internal_default_instance() {
    return reinterpret_cast<const GroupList*>(
               &_GroupList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GroupList& a, GroupList& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GroupList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.GroupList";
  }
  protected:
  explicit GroupList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
  };
  // repeated .fixbug.Group group = 1;
  int group_size() const;
  private:
  int _internal_group_size() const;
  public:
  void clear_group();
  ::fixbug::Group* mutable_group(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::Group >*
      mutable_group();
  private:
  const ::fixbug::Group& _internal_group(int index) const;
  ::fixbug::Group* _internal_add_group();
  public:
  const ::fixbug::Group& group(int index) const;
  ::fixbug::Group* add_group();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::Group >&
      group() const;

  // @@protoc_insertion_point(class_scope:fixbug.GroupList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::Group > group_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  explicit constexpr ChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChatMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.ChatMessage";
  }
  protected:
  explicit ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChattimeFieldNumber = 1,
    kUseridFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kGroupidFieldNumber = 4,
    kGroupnameFieldNumber = 5,
    kMsgFieldNumber = 6,
    kMsgtypeFieldNumber = 7,
  };
  // bytes chattime = 1;
  void clear_chattime();
  const std::string& chattime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chattime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chattime();
  PROTOBUF_NODISCARD std::string* release_chattime();
  void set_allocated_chattime(std::string* chattime);
  private:
  const std::string& _internal_chattime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chattime(const std::string& value);
  std::string* _internal_mutable_chattime();
  public:

  // bytes userid = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // bytes groupid = 4;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // bytes groupname = 5;
  void clear_groupname();
  const std::string& groupname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupname();
  PROTOBUF_NODISCARD std::string* release_groupname();
  void set_allocated_groupname(std::string* groupname);
  private:
  const std::string& _internal_groupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupname(const std::string& value);
  std::string* _internal_mutable_groupname();
  public:

  // bytes msg = 6;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 msgtype = 7;
  void clear_msgtype();
  int32_t msgtype() const;
  void set_msgtype(int32_t value);
  private:
  int32_t _internal_msgtype() const;
  void _internal_set_msgtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:fixbug.ChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chattime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  int32_t msgtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class protobuffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.protobuffer) */ {
 public:
  inline protobuffer() : protobuffer(nullptr) {}
  ~protobuffer() override;
  explicit constexpr protobuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  protobuffer(const protobuffer& from);
  protobuffer(protobuffer&& from) noexcept
    : protobuffer() {
    *this = ::std::move(from);
  }

  inline protobuffer& operator=(const protobuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline protobuffer& operator=(protobuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const protobuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const protobuffer* internal_default_instance() {
    return reinterpret_cast<const protobuffer*>(
               &_protobuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(protobuffer& a, protobuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(protobuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(protobuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  protobuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<protobuffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const protobuffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const protobuffer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(protobuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.protobuffer";
  }
  protected:
  explicit protobuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtobufstrFieldNumber = 2,
    kProtobuftypeFieldNumber = 1,
  };
  // bytes protobufstr = 2;
  void clear_protobufstr();
  const std::string& protobufstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protobufstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protobufstr();
  PROTOBUF_NODISCARD std::string* release_protobufstr();
  void set_allocated_protobufstr(std::string* protobufstr);
  private:
  const std::string& _internal_protobufstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protobufstr(const std::string& value);
  std::string* _internal_mutable_protobufstr();
  public:

  // int32 protobuftype = 1;
  void clear_protobuftype();
  int32_t protobuftype() const;
  void set_protobuftype(int32_t value);
  private:
  int32_t _internal_protobuftype() const;
  void _internal_set_protobuftype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:fixbug.protobuffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protobufstr_;
  int32_t protobuftype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit constexpr LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit constexpr LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfflinemsglistFieldNumber = 6,
    kUseridFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kResultFieldNumber = 1,
    kFriendlistFieldNumber = 4,
    kGrouplistFieldNumber = 5,
  };
  // repeated .fixbug.ChatMessage offlinemsglist = 6;
  int offlinemsglist_size() const;
  private:
  int _internal_offlinemsglist_size() const;
  public:
  void clear_offlinemsglist();
  ::fixbug::ChatMessage* mutable_offlinemsglist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage >*
      mutable_offlinemsglist();
  private:
  const ::fixbug::ChatMessage& _internal_offlinemsglist(int index) const;
  ::fixbug::ChatMessage* _internal_add_offlinemsglist();
  public:
  const ::fixbug::ChatMessage& offlinemsglist(int index) const;
  ::fixbug::ChatMessage* add_offlinemsglist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage >&
      offlinemsglist() const;

  // bytes userid = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // .fixbug.FriendList friendlist = 4;
  bool has_friendlist() const;
  private:
  bool _internal_has_friendlist() const;
  public:
  void clear_friendlist();
  const ::fixbug::FriendList& friendlist() const;
  PROTOBUF_NODISCARD ::fixbug::FriendList* release_friendlist();
  ::fixbug::FriendList* mutable_friendlist();
  void set_allocated_friendlist(::fixbug::FriendList* friendlist);
  private:
  const ::fixbug::FriendList& _internal_friendlist() const;
  ::fixbug::FriendList* _internal_mutable_friendlist();
  public:
  void unsafe_arena_set_allocated_friendlist(
      ::fixbug::FriendList* friendlist);
  ::fixbug::FriendList* unsafe_arena_release_friendlist();

  // .fixbug.GroupList grouplist = 5;
  bool has_grouplist() const;
  private:
  bool _internal_has_grouplist() const;
  public:
  void clear_grouplist();
  const ::fixbug::GroupList& grouplist() const;
  PROTOBUF_NODISCARD ::fixbug::GroupList* release_grouplist();
  ::fixbug::GroupList* mutable_grouplist();
  void set_allocated_grouplist(::fixbug::GroupList* grouplist);
  private:
  const ::fixbug::GroupList& _internal_grouplist() const;
  ::fixbug::GroupList* _internal_mutable_grouplist();
  public:
  void unsafe_arena_set_allocated_grouplist(
      ::fixbug::GroupList* grouplist);
  ::fixbug::GroupList* unsafe_arena_release_grouplist();

  // @@protoc_insertion_point(class_scope:fixbug.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage > offlinemsglist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::fixbug::RequestResult* result_;
  ::fixbug::FriendList* friendlist_;
  ::fixbug::GroupList* grouplist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class LoginoutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.LoginoutRequest) */ {
 public:
  inline LoginoutRequest() : LoginoutRequest(nullptr) {}
  ~LoginoutRequest() override;
  explicit constexpr LoginoutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginoutRequest(const LoginoutRequest& from);
  LoginoutRequest(LoginoutRequest&& from) noexcept
    : LoginoutRequest() {
    *this = ::std::move(from);
  }

  inline LoginoutRequest& operator=(const LoginoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginoutRequest& operator=(LoginoutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginoutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginoutRequest* internal_default_instance() {
    return reinterpret_cast<const LoginoutRequest*>(
               &_LoginoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LoginoutRequest& a, LoginoutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginoutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginoutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginoutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginoutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginoutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginoutRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginoutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.LoginoutRequest";
  }
  protected:
  explicit LoginoutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.LoginoutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class LoginoutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.LoginoutResponse) */ {
 public:
  inline LoginoutResponse() : LoginoutResponse(nullptr) {}
  ~LoginoutResponse() override;
  explicit constexpr LoginoutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginoutResponse(const LoginoutResponse& from);
  LoginoutResponse(LoginoutResponse&& from) noexcept
    : LoginoutResponse() {
    *this = ::std::move(from);
  }

  inline LoginoutResponse& operator=(const LoginoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginoutResponse& operator=(LoginoutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginoutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginoutResponse* internal_default_instance() {
    return reinterpret_cast<const LoginoutResponse*>(
               &_LoginoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LoginoutResponse& a, LoginoutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginoutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginoutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginoutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginoutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginoutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginoutResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginoutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.LoginoutResponse";
  }
  protected:
  explicit LoginoutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:fixbug.LoginoutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fixbug::RequestResult* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit constexpr RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // bytes username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // bytes password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  explicit constexpr RegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // bytes userid = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:fixbug.RegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::fixbug::RequestResult* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class GetFriendListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.GetFriendListRequest) */ {
 public:
  inline GetFriendListRequest() : GetFriendListRequest(nullptr) {}
  ~GetFriendListRequest() override;
  explicit constexpr GetFriendListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFriendListRequest(const GetFriendListRequest& from);
  GetFriendListRequest(GetFriendListRequest&& from) noexcept
    : GetFriendListRequest() {
    *this = ::std::move(from);
  }

  inline GetFriendListRequest& operator=(const GetFriendListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFriendListRequest& operator=(GetFriendListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFriendListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFriendListRequest* internal_default_instance() {
    return reinterpret_cast<const GetFriendListRequest*>(
               &_GetFriendListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetFriendListRequest& a, GetFriendListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFriendListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFriendListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFriendListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFriendListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFriendListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFriendListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFriendListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.GetFriendListRequest";
  }
  protected:
  explicit GetFriendListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.GetFriendListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class GetFriendListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.GetFriendListResponse) */ {
 public:
  inline GetFriendListResponse() : GetFriendListResponse(nullptr) {}
  ~GetFriendListResponse() override;
  explicit constexpr GetFriendListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFriendListResponse(const GetFriendListResponse& from);
  GetFriendListResponse(GetFriendListResponse&& from) noexcept
    : GetFriendListResponse() {
    *this = ::std::move(from);
  }

  inline GetFriendListResponse& operator=(const GetFriendListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFriendListResponse& operator=(GetFriendListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFriendListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFriendListResponse* internal_default_instance() {
    return reinterpret_cast<const GetFriendListResponse*>(
               &_GetFriendListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetFriendListResponse& a, GetFriendListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFriendListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFriendListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFriendListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFriendListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFriendListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFriendListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFriendListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.GetFriendListResponse";
  }
  protected:
  explicit GetFriendListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kFriendlistFieldNumber = 2,
  };
  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // .fixbug.FriendList friendlist = 2;
  bool has_friendlist() const;
  private:
  bool _internal_has_friendlist() const;
  public:
  void clear_friendlist();
  const ::fixbug::FriendList& friendlist() const;
  PROTOBUF_NODISCARD ::fixbug::FriendList* release_friendlist();
  ::fixbug::FriendList* mutable_friendlist();
  void set_allocated_friendlist(::fixbug::FriendList* friendlist);
  private:
  const ::fixbug::FriendList& _internal_friendlist() const;
  ::fixbug::FriendList* _internal_mutable_friendlist();
  public:
  void unsafe_arena_set_allocated_friendlist(
      ::fixbug::FriendList* friendlist);
  ::fixbug::FriendList* unsafe_arena_release_friendlist();

  // @@protoc_insertion_point(class_scope:fixbug.GetFriendListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fixbug::RequestResult* result_;
  ::fixbug::FriendList* friendlist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class AddFriendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.AddFriendRequest) */ {
 public:
  inline AddFriendRequest() : AddFriendRequest(nullptr) {}
  ~AddFriendRequest() override;
  explicit constexpr AddFriendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddFriendRequest(const AddFriendRequest& from);
  AddFriendRequest(AddFriendRequest&& from) noexcept
    : AddFriendRequest() {
    *this = ::std::move(from);
  }

  inline AddFriendRequest& operator=(const AddFriendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFriendRequest& operator=(AddFriendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddFriendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddFriendRequest* internal_default_instance() {
    return reinterpret_cast<const AddFriendRequest*>(
               &_AddFriendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AddFriendRequest& a, AddFriendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFriendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddFriendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddFriendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddFriendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddFriendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddFriendRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFriendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.AddFriendRequest";
  }
  protected:
  explicit AddFriendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kFriendidFieldNumber = 2,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes friendid = 2;
  void clear_friendid();
  const std::string& friendid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_friendid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_friendid();
  PROTOBUF_NODISCARD std::string* release_friendid();
  void set_allocated_friendid(std::string* friendid);
  private:
  const std::string& _internal_friendid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_friendid(const std::string& value);
  std::string* _internal_mutable_friendid();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.AddFriendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr friendid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class AddFriendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.AddFriendResponse) */ {
 public:
  inline AddFriendResponse() : AddFriendResponse(nullptr) {}
  ~AddFriendResponse() override;
  explicit constexpr AddFriendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddFriendResponse(const AddFriendResponse& from);
  AddFriendResponse(AddFriendResponse&& from) noexcept
    : AddFriendResponse() {
    *this = ::std::move(from);
  }

  inline AddFriendResponse& operator=(const AddFriendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFriendResponse& operator=(AddFriendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddFriendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddFriendResponse* internal_default_instance() {
    return reinterpret_cast<const AddFriendResponse*>(
               &_AddFriendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AddFriendResponse& a, AddFriendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFriendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddFriendResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddFriendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddFriendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddFriendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddFriendResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFriendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.AddFriendResponse";
  }
  protected:
  explicit AddFriendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:fixbug.AddFriendResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fixbug::RequestResult* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class GetGroupListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.GetGroupListRequest) */ {
 public:
  inline GetGroupListRequest() : GetGroupListRequest(nullptr) {}
  ~GetGroupListRequest() override;
  explicit constexpr GetGroupListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetGroupListRequest(const GetGroupListRequest& from);
  GetGroupListRequest(GetGroupListRequest&& from) noexcept
    : GetGroupListRequest() {
    *this = ::std::move(from);
  }

  inline GetGroupListRequest& operator=(const GetGroupListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGroupListRequest& operator=(GetGroupListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetGroupListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetGroupListRequest* internal_default_instance() {
    return reinterpret_cast<const GetGroupListRequest*>(
               &_GetGroupListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetGroupListRequest& a, GetGroupListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGroupListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGroupListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetGroupListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetGroupListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetGroupListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetGroupListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGroupListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.GetGroupListRequest";
  }
  protected:
  explicit GetGroupListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.GetGroupListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class GetGroupListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.GetGroupListResponse) */ {
 public:
  inline GetGroupListResponse() : GetGroupListResponse(nullptr) {}
  ~GetGroupListResponse() override;
  explicit constexpr GetGroupListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetGroupListResponse(const GetGroupListResponse& from);
  GetGroupListResponse(GetGroupListResponse&& from) noexcept
    : GetGroupListResponse() {
    *this = ::std::move(from);
  }

  inline GetGroupListResponse& operator=(const GetGroupListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGroupListResponse& operator=(GetGroupListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetGroupListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetGroupListResponse* internal_default_instance() {
    return reinterpret_cast<const GetGroupListResponse*>(
               &_GetGroupListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetGroupListResponse& a, GetGroupListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGroupListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGroupListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetGroupListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetGroupListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetGroupListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetGroupListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGroupListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.GetGroupListResponse";
  }
  protected:
  explicit GetGroupListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kGrouplistFieldNumber = 2,
  };
  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // .fixbug.GroupList grouplist = 2;
  bool has_grouplist() const;
  private:
  bool _internal_has_grouplist() const;
  public:
  void clear_grouplist();
  const ::fixbug::GroupList& grouplist() const;
  PROTOBUF_NODISCARD ::fixbug::GroupList* release_grouplist();
  ::fixbug::GroupList* mutable_grouplist();
  void set_allocated_grouplist(::fixbug::GroupList* grouplist);
  private:
  const ::fixbug::GroupList& _internal_grouplist() const;
  ::fixbug::GroupList* _internal_mutable_grouplist();
  public:
  void unsafe_arena_set_allocated_grouplist(
      ::fixbug::GroupList* grouplist);
  ::fixbug::GroupList* unsafe_arena_release_grouplist();

  // @@protoc_insertion_point(class_scope:fixbug.GetGroupListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fixbug::RequestResult* result_;
  ::fixbug::GroupList* grouplist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class CreateGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.CreateGroupRequest) */ {
 public:
  inline CreateGroupRequest() : CreateGroupRequest(nullptr) {}
  ~CreateGroupRequest() override;
  explicit constexpr CreateGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGroupRequest(const CreateGroupRequest& from);
  CreateGroupRequest(CreateGroupRequest&& from) noexcept
    : CreateGroupRequest() {
    *this = ::std::move(from);
  }

  inline CreateGroupRequest& operator=(const CreateGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGroupRequest& operator=(CreateGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGroupRequest* internal_default_instance() {
    return reinterpret_cast<const CreateGroupRequest*>(
               &_CreateGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateGroupRequest& a, CreateGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateGroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGroupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.CreateGroupRequest";
  }
  protected:
  explicit CreateGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kGroupnameFieldNumber = 2,
    kGroupdescFieldNumber = 3,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes groupname = 2;
  void clear_groupname();
  const std::string& groupname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupname();
  PROTOBUF_NODISCARD std::string* release_groupname();
  void set_allocated_groupname(std::string* groupname);
  private:
  const std::string& _internal_groupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupname(const std::string& value);
  std::string* _internal_mutable_groupname();
  public:

  // bytes groupdesc = 3;
  void clear_groupdesc();
  const std::string& groupdesc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupdesc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupdesc();
  PROTOBUF_NODISCARD std::string* release_groupdesc();
  void set_allocated_groupdesc(std::string* groupdesc);
  private:
  const std::string& _internal_groupdesc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupdesc(const std::string& value);
  std::string* _internal_mutable_groupdesc();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.CreateGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupdesc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class CreateGroupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.CreateGroupResponse) */ {
 public:
  inline CreateGroupResponse() : CreateGroupResponse(nullptr) {}
  ~CreateGroupResponse() override;
  explicit constexpr CreateGroupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGroupResponse(const CreateGroupResponse& from);
  CreateGroupResponse(CreateGroupResponse&& from) noexcept
    : CreateGroupResponse() {
    *this = ::std::move(from);
  }

  inline CreateGroupResponse& operator=(const CreateGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGroupResponse& operator=(CreateGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGroupResponse* internal_default_instance() {
    return reinterpret_cast<const CreateGroupResponse*>(
               &_CreateGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateGroupResponse& a, CreateGroupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGroupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGroupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGroupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGroupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGroupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateGroupResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGroupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.CreateGroupResponse";
  }
  protected:
  explicit CreateGroupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupidFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // bytes groupid = 2;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:fixbug.CreateGroupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
  ::fixbug::RequestResult* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class AddGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.AddGroupRequest) */ {
 public:
  inline AddGroupRequest() : AddGroupRequest(nullptr) {}
  ~AddGroupRequest() override;
  explicit constexpr AddGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddGroupRequest(const AddGroupRequest& from);
  AddGroupRequest(AddGroupRequest&& from) noexcept
    : AddGroupRequest() {
    *this = ::std::move(from);
  }

  inline AddGroupRequest& operator=(const AddGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddGroupRequest& operator=(AddGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddGroupRequest* internal_default_instance() {
    return reinterpret_cast<const AddGroupRequest*>(
               &_AddGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AddGroupRequest& a, AddGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddGroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddGroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddGroupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.AddGroupRequest";
  }
  protected:
  explicit AddGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kGroupidFieldNumber = 2,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes groupid = 2;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.AddGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class AddGroupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.AddGroupResponse) */ {
 public:
  inline AddGroupResponse() : AddGroupResponse(nullptr) {}
  ~AddGroupResponse() override;
  explicit constexpr AddGroupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddGroupResponse(const AddGroupResponse& from);
  AddGroupResponse(AddGroupResponse&& from) noexcept
    : AddGroupResponse() {
    *this = ::std::move(from);
  }

  inline AddGroupResponse& operator=(const AddGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddGroupResponse& operator=(AddGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddGroupResponse* internal_default_instance() {
    return reinterpret_cast<const AddGroupResponse*>(
               &_AddGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AddGroupResponse& a, AddGroupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddGroupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddGroupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddGroupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddGroupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddGroupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddGroupResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddGroupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.AddGroupResponse";
  }
  protected:
  explicit AddGroupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:fixbug.AddGroupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fixbug::RequestResult* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class OneChatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.OneChatRequest) */ {
 public:
  inline OneChatRequest() : OneChatRequest(nullptr) {}
  ~OneChatRequest() override;
  explicit constexpr OneChatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneChatRequest(const OneChatRequest& from);
  OneChatRequest(OneChatRequest&& from) noexcept
    : OneChatRequest() {
    *this = ::std::move(from);
  }

  inline OneChatRequest& operator=(const OneChatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneChatRequest& operator=(OneChatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneChatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneChatRequest* internal_default_instance() {
    return reinterpret_cast<const OneChatRequest*>(
               &_OneChatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(OneChatRequest& a, OneChatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OneChatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneChatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneChatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneChatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneChatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OneChatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneChatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.OneChatRequest";
  }
  protected:
  explicit OneChatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kFriendidFieldNumber = 2,
    kChatmsgFieldNumber = 3,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes friendid = 2;
  void clear_friendid();
  const std::string& friendid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_friendid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_friendid();
  PROTOBUF_NODISCARD std::string* release_friendid();
  void set_allocated_friendid(std::string* friendid);
  private:
  const std::string& _internal_friendid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_friendid(const std::string& value);
  std::string* _internal_mutable_friendid();
  public:

  // .fixbug.ChatMessage chatmsg = 3;
  bool has_chatmsg() const;
  private:
  bool _internal_has_chatmsg() const;
  public:
  void clear_chatmsg();
  const ::fixbug::ChatMessage& chatmsg() const;
  PROTOBUF_NODISCARD ::fixbug::ChatMessage* release_chatmsg();
  ::fixbug::ChatMessage* mutable_chatmsg();
  void set_allocated_chatmsg(::fixbug::ChatMessage* chatmsg);
  private:
  const ::fixbug::ChatMessage& _internal_chatmsg() const;
  ::fixbug::ChatMessage* _internal_mutable_chatmsg();
  public:
  void unsafe_arena_set_allocated_chatmsg(
      ::fixbug::ChatMessage* chatmsg);
  ::fixbug::ChatMessage* unsafe_arena_release_chatmsg();

  // @@protoc_insertion_point(class_scope:fixbug.OneChatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr friendid_;
  ::fixbug::ChatMessage* chatmsg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class OneChatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.OneChatResponse) */ {
 public:
  inline OneChatResponse() : OneChatResponse(nullptr) {}
  ~OneChatResponse() override;
  explicit constexpr OneChatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneChatResponse(const OneChatResponse& from);
  OneChatResponse(OneChatResponse&& from) noexcept
    : OneChatResponse() {
    *this = ::std::move(from);
  }

  inline OneChatResponse& operator=(const OneChatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneChatResponse& operator=(OneChatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneChatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneChatResponse* internal_default_instance() {
    return reinterpret_cast<const OneChatResponse*>(
               &_OneChatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(OneChatResponse& a, OneChatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OneChatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneChatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneChatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneChatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneChatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OneChatResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneChatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.OneChatResponse";
  }
  protected:
  explicit OneChatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:fixbug.OneChatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fixbug::RequestResult* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class GroupChatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.GroupChatRequest) */ {
 public:
  inline GroupChatRequest() : GroupChatRequest(nullptr) {}
  ~GroupChatRequest() override;
  explicit constexpr GroupChatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupChatRequest(const GroupChatRequest& from);
  GroupChatRequest(GroupChatRequest&& from) noexcept
    : GroupChatRequest() {
    *this = ::std::move(from);
  }

  inline GroupChatRequest& operator=(const GroupChatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupChatRequest& operator=(GroupChatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupChatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupChatRequest* internal_default_instance() {
    return reinterpret_cast<const GroupChatRequest*>(
               &_GroupChatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GroupChatRequest& a, GroupChatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupChatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupChatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupChatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupChatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupChatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GroupChatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupChatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.GroupChatRequest";
  }
  protected:
  explicit GroupChatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kGroupidFieldNumber = 2,
    kChatmsgFieldNumber = 3,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bytes groupid = 2;
  void clear_groupid();
  const std::string& groupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_groupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_groupid();
  PROTOBUF_NODISCARD std::string* release_groupid();
  void set_allocated_groupid(std::string* groupid);
  private:
  const std::string& _internal_groupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_groupid(const std::string& value);
  std::string* _internal_mutable_groupid();
  public:

  // .fixbug.ChatMessage chatmsg = 3;
  bool has_chatmsg() const;
  private:
  bool _internal_has_chatmsg() const;
  public:
  void clear_chatmsg();
  const ::fixbug::ChatMessage& chatmsg() const;
  PROTOBUF_NODISCARD ::fixbug::ChatMessage* release_chatmsg();
  ::fixbug::ChatMessage* mutable_chatmsg();
  void set_allocated_chatmsg(::fixbug::ChatMessage* chatmsg);
  private:
  const ::fixbug::ChatMessage& _internal_chatmsg() const;
  ::fixbug::ChatMessage* _internal_mutable_chatmsg();
  public:
  void unsafe_arena_set_allocated_chatmsg(
      ::fixbug::ChatMessage* chatmsg);
  ::fixbug::ChatMessage* unsafe_arena_release_chatmsg();

  // @@protoc_insertion_point(class_scope:fixbug.GroupChatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr groupid_;
  ::fixbug::ChatMessage* chatmsg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class GroupChatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.GroupChatResponse) */ {
 public:
  inline GroupChatResponse() : GroupChatResponse(nullptr) {}
  ~GroupChatResponse() override;
  explicit constexpr GroupChatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupChatResponse(const GroupChatResponse& from);
  GroupChatResponse(GroupChatResponse&& from) noexcept
    : GroupChatResponse() {
    *this = ::std::move(from);
  }

  inline GroupChatResponse& operator=(const GroupChatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupChatResponse& operator=(GroupChatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupChatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupChatResponse* internal_default_instance() {
    return reinterpret_cast<const GroupChatResponse*>(
               &_GroupChatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GroupChatResponse& a, GroupChatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupChatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupChatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupChatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupChatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupChatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GroupChatResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupChatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.GroupChatResponse";
  }
  protected:
  explicit GroupChatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:fixbug.GroupChatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::fixbug::RequestResult* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class GetOfflineMsgRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.GetOfflineMsgRequest) */ {
 public:
  inline GetOfflineMsgRequest() : GetOfflineMsgRequest(nullptr) {}
  ~GetOfflineMsgRequest() override;
  explicit constexpr GetOfflineMsgRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOfflineMsgRequest(const GetOfflineMsgRequest& from);
  GetOfflineMsgRequest(GetOfflineMsgRequest&& from) noexcept
    : GetOfflineMsgRequest() {
    *this = ::std::move(from);
  }

  inline GetOfflineMsgRequest& operator=(const GetOfflineMsgRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOfflineMsgRequest& operator=(GetOfflineMsgRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOfflineMsgRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOfflineMsgRequest* internal_default_instance() {
    return reinterpret_cast<const GetOfflineMsgRequest*>(
               &_GetOfflineMsgRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetOfflineMsgRequest& a, GetOfflineMsgRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOfflineMsgRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOfflineMsgRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOfflineMsgRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOfflineMsgRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOfflineMsgRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOfflineMsgRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOfflineMsgRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.GetOfflineMsgRequest";
  }
  protected:
  explicit GetOfflineMsgRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
  };
  // bytes userid = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:fixbug.GetOfflineMsgRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// -------------------------------------------------------------------

class GetOfflineMsgResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fixbug.GetOfflineMsgResponse) */ {
 public:
  inline GetOfflineMsgResponse() : GetOfflineMsgResponse(nullptr) {}
  ~GetOfflineMsgResponse() override;
  explicit constexpr GetOfflineMsgResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOfflineMsgResponse(const GetOfflineMsgResponse& from);
  GetOfflineMsgResponse(GetOfflineMsgResponse&& from) noexcept
    : GetOfflineMsgResponse() {
    *this = ::std::move(from);
  }

  inline GetOfflineMsgResponse& operator=(const GetOfflineMsgResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOfflineMsgResponse& operator=(GetOfflineMsgResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOfflineMsgResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOfflineMsgResponse* internal_default_instance() {
    return reinterpret_cast<const GetOfflineMsgResponse*>(
               &_GetOfflineMsgResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetOfflineMsgResponse& a, GetOfflineMsgResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOfflineMsgResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOfflineMsgResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOfflineMsgResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOfflineMsgResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOfflineMsgResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetOfflineMsgResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOfflineMsgResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fixbug.GetOfflineMsgResponse";
  }
  protected:
  explicit GetOfflineMsgResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfflinemsglistFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .fixbug.ChatMessage offlinemsglist = 2;
  int offlinemsglist_size() const;
  private:
  int _internal_offlinemsglist_size() const;
  public:
  void clear_offlinemsglist();
  ::fixbug::ChatMessage* mutable_offlinemsglist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage >*
      mutable_offlinemsglist();
  private:
  const ::fixbug::ChatMessage& _internal_offlinemsglist(int index) const;
  ::fixbug::ChatMessage* _internal_add_offlinemsglist();
  public:
  const ::fixbug::ChatMessage& offlinemsglist(int index) const;
  ::fixbug::ChatMessage* add_offlinemsglist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage >&
      offlinemsglist() const;

  // .fixbug.RequestResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::fixbug::RequestResult& result() const;
  PROTOBUF_NODISCARD ::fixbug::RequestResult* release_result();
  ::fixbug::RequestResult* mutable_result();
  void set_allocated_result(::fixbug::RequestResult* result);
  private:
  const ::fixbug::RequestResult& _internal_result() const;
  ::fixbug::RequestResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::fixbug::RequestResult* result);
  ::fixbug::RequestResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:fixbug.GetOfflineMsgResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage > offlinemsglist_;
  ::fixbug::RequestResult* result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qq_2eproto;
};
// ===================================================================

class UserServiceRpc_Stub;

class UserServiceRpc : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline UserServiceRpc() {};
 public:
  virtual ~UserServiceRpc();

  typedef UserServiceRpc_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void Login(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::LoginRequest* request,
                       ::fixbug::LoginResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void Loginout(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::LoginoutRequest* request,
                       ::fixbug::LoginoutResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void Register(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::RegisterRequest* request,
                       ::fixbug::RegisterResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(UserServiceRpc);
};

class UserServiceRpc_Stub : public UserServiceRpc {
 public:
  UserServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  UserServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~UserServiceRpc_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements UserServiceRpc ------------------------------------------

  void Login(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::LoginRequest* request,
                       ::fixbug::LoginResponse* response,
                       ::google::protobuf::Closure* done);
  void Loginout(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::LoginoutRequest* request,
                       ::fixbug::LoginoutResponse* response,
                       ::google::protobuf::Closure* done);
  void Register(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::RegisterRequest* request,
                       ::fixbug::RegisterResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(UserServiceRpc_Stub);
};


// -------------------------------------------------------------------

class FriendServiceRpc_Stub;

class FriendServiceRpc : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline FriendServiceRpc() {};
 public:
  virtual ~FriendServiceRpc();

  typedef FriendServiceRpc_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void GetFriendList(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::GetFriendListRequest* request,
                       ::fixbug::GetFriendListResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void AddFriend(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::AddFriendRequest* request,
                       ::fixbug::AddFriendResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(FriendServiceRpc);
};

class FriendServiceRpc_Stub : public FriendServiceRpc {
 public:
  FriendServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  FriendServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~FriendServiceRpc_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements FriendServiceRpc ------------------------------------------

  void GetFriendList(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::GetFriendListRequest* request,
                       ::fixbug::GetFriendListResponse* response,
                       ::google::protobuf::Closure* done);
  void AddFriend(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::AddFriendRequest* request,
                       ::fixbug::AddFriendResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(FriendServiceRpc_Stub);
};


// -------------------------------------------------------------------

class GroupServiceRpc_Stub;

class GroupServiceRpc : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline GroupServiceRpc() {};
 public:
  virtual ~GroupServiceRpc();

  typedef GroupServiceRpc_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void GetGroupList(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::GetGroupListRequest* request,
                       ::fixbug::GetGroupListResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void CreateGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::CreateGroupRequest* request,
                       ::fixbug::CreateGroupResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void AddGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::AddGroupRequest* request,
                       ::fixbug::AddGroupResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GroupServiceRpc);
};

class GroupServiceRpc_Stub : public GroupServiceRpc {
 public:
  GroupServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  GroupServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~GroupServiceRpc_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements GroupServiceRpc ------------------------------------------

  void GetGroupList(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::GetGroupListRequest* request,
                       ::fixbug::GetGroupListResponse* response,
                       ::google::protobuf::Closure* done);
  void CreateGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::CreateGroupRequest* request,
                       ::fixbug::CreateGroupResponse* response,
                       ::google::protobuf::Closure* done);
  void AddGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::AddGroupRequest* request,
                       ::fixbug::AddGroupResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GroupServiceRpc_Stub);
};


// -------------------------------------------------------------------

class MsgServiceRpc_Stub;

class MsgServiceRpc : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MsgServiceRpc() {};
 public:
  virtual ~MsgServiceRpc();

  typedef MsgServiceRpc_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void OneChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::OneChatRequest* request,
                       ::fixbug::OneChatResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GroupChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::GroupChatRequest* request,
                       ::fixbug::GroupChatResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetOfflineMsg(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::GetOfflineMsgRequest* request,
                       ::fixbug::GetOfflineMsgResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MsgServiceRpc);
};

class MsgServiceRpc_Stub : public MsgServiceRpc {
 public:
  MsgServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  MsgServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~MsgServiceRpc_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements MsgServiceRpc ------------------------------------------

  void OneChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::OneChatRequest* request,
                       ::fixbug::OneChatResponse* response,
                       ::google::protobuf::Closure* done);
  void GroupChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::GroupChatRequest* request,
                       ::fixbug::GroupChatResponse* response,
                       ::google::protobuf::Closure* done);
  void GetOfflineMsg(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::fixbug::GetOfflineMsgRequest* request,
                       ::fixbug::GetOfflineMsgResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MsgServiceRpc_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestResult

// bool success = 1;
inline void RequestResult::clear_success() {
  success_ = false;
}
inline bool RequestResult::_internal_success() const {
  return success_;
}
inline bool RequestResult::success() const {
  // @@protoc_insertion_point(field_get:fixbug.RequestResult.success)
  return _internal_success();
}
inline void RequestResult::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RequestResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:fixbug.RequestResult.success)
}

// bytes errmsg = 2;
inline void RequestResult::clear_errmsg() {
  errmsg_.ClearToEmpty();
}
inline const std::string& RequestResult::errmsg() const {
  // @@protoc_insertion_point(field_get:fixbug.RequestResult.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestResult::set_errmsg(ArgT0&& arg0, ArgT... args) {
 
 errmsg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.RequestResult.errmsg)
}
inline std::string* RequestResult::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:fixbug.RequestResult.errmsg)
  return _s;
}
inline const std::string& RequestResult::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void RequestResult::_internal_set_errmsg(const std::string& value) {
  
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestResult::_internal_mutable_errmsg() {
  
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestResult::release_errmsg() {
  // @@protoc_insertion_point(field_release:fixbug.RequestResult.errmsg)
  return errmsg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestResult::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    
  } else {
    
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (errmsg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    errmsg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.RequestResult.errmsg)
}

// -------------------------------------------------------------------

// User

// bytes userid = 1;
inline void User::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& User::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.User.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.User.userid)
}
inline std::string* User::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.User.userid)
  return _s;
}
inline const std::string& User::_internal_userid() const {
  return userid_.Get();
}
inline void User::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.User.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.User.userid)
}

// bytes username = 2;
inline void User::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& User::username() const {
  // @@protoc_insertion_point(field_get:fixbug.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.User.username)
}
inline std::string* User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:fixbug.User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  return username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:fixbug.User.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.User.username)
}

// bytes userstate = 3;
inline void User::clear_userstate() {
  userstate_.ClearToEmpty();
}
inline const std::string& User::userstate() const {
  // @@protoc_insertion_point(field_get:fixbug.User.userstate)
  return _internal_userstate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_userstate(ArgT0&& arg0, ArgT... args) {
 
 userstate_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.User.userstate)
}
inline std::string* User::mutable_userstate() {
  std::string* _s = _internal_mutable_userstate();
  // @@protoc_insertion_point(field_mutable:fixbug.User.userstate)
  return _s;
}
inline const std::string& User::_internal_userstate() const {
  return userstate_.Get();
}
inline void User::_internal_set_userstate(const std::string& value) {
  
  userstate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_userstate() {
  
  return userstate_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_userstate() {
  // @@protoc_insertion_point(field_release:fixbug.User.userstate)
  return userstate_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_userstate(std::string* userstate) {
  if (userstate != nullptr) {
    
  } else {
    
  }
  userstate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userstate,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userstate_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userstate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.User.userstate)
}

// -------------------------------------------------------------------

// FriendList

// repeated .fixbug.User friend = 1;
inline int FriendList::_internal_friend__size() const {
  return friend__.size();
}
inline int FriendList::friend__size() const {
  return _internal_friend__size();
}
inline void FriendList::clear_friend_() {
  friend__.Clear();
}
inline ::fixbug::User* FriendList::mutable_friend_(int index) {
  // @@protoc_insertion_point(field_mutable:fixbug.FriendList.friend)
  return friend__.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User >*
FriendList::mutable_friend_() {
  // @@protoc_insertion_point(field_mutable_list:fixbug.FriendList.friend)
  return &friend__;
}
inline const ::fixbug::User& FriendList::_internal_friend_(int index) const {
  return friend__.Get(index);
}
inline const ::fixbug::User& FriendList::friend_(int index) const {
  // @@protoc_insertion_point(field_get:fixbug.FriendList.friend)
  return _internal_friend_(index);
}
inline ::fixbug::User* FriendList::_internal_add_friend_() {
  return friend__.Add();
}
inline ::fixbug::User* FriendList::add_friend_() {
  ::fixbug::User* _add = _internal_add_friend_();
  // @@protoc_insertion_point(field_add:fixbug.FriendList.friend)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User >&
FriendList::friend_() const {
  // @@protoc_insertion_point(field_list:fixbug.FriendList.friend)
  return friend__;
}

// -------------------------------------------------------------------

// Group

// bytes groupid = 1;
inline void Group::clear_groupid() {
  groupid_.ClearToEmpty();
}
inline const std::string& Group::groupid() const {
  // @@protoc_insertion_point(field_get:fixbug.Group.groupid)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Group::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 groupid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.Group.groupid)
}
inline std::string* Group::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:fixbug.Group.groupid)
  return _s;
}
inline const std::string& Group::_internal_groupid() const {
  return groupid_.Get();
}
inline void Group::_internal_set_groupid(const std::string& value) {
  
  groupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Group::_internal_mutable_groupid() {
  
  return groupid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Group::release_groupid() {
  // @@protoc_insertion_point(field_release:fixbug.Group.groupid)
  return groupid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Group::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  groupid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.Group.groupid)
}

// bytes groupname = 2;
inline void Group::clear_groupname() {
  groupname_.ClearToEmpty();
}
inline const std::string& Group::groupname() const {
  // @@protoc_insertion_point(field_get:fixbug.Group.groupname)
  return _internal_groupname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Group::set_groupname(ArgT0&& arg0, ArgT... args) {
 
 groupname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.Group.groupname)
}
inline std::string* Group::mutable_groupname() {
  std::string* _s = _internal_mutable_groupname();
  // @@protoc_insertion_point(field_mutable:fixbug.Group.groupname)
  return _s;
}
inline const std::string& Group::_internal_groupname() const {
  return groupname_.Get();
}
inline void Group::_internal_set_groupname(const std::string& value) {
  
  groupname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Group::_internal_mutable_groupname() {
  
  return groupname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Group::release_groupname() {
  // @@protoc_insertion_point(field_release:fixbug.Group.groupname)
  return groupname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Group::set_allocated_groupname(std::string* groupname) {
  if (groupname != nullptr) {
    
  } else {
    
  }
  groupname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.Group.groupname)
}

// bytes groupdesc = 3;
inline void Group::clear_groupdesc() {
  groupdesc_.ClearToEmpty();
}
inline const std::string& Group::groupdesc() const {
  // @@protoc_insertion_point(field_get:fixbug.Group.groupdesc)
  return _internal_groupdesc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Group::set_groupdesc(ArgT0&& arg0, ArgT... args) {
 
 groupdesc_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.Group.groupdesc)
}
inline std::string* Group::mutable_groupdesc() {
  std::string* _s = _internal_mutable_groupdesc();
  // @@protoc_insertion_point(field_mutable:fixbug.Group.groupdesc)
  return _s;
}
inline const std::string& Group::_internal_groupdesc() const {
  return groupdesc_.Get();
}
inline void Group::_internal_set_groupdesc(const std::string& value) {
  
  groupdesc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Group::_internal_mutable_groupdesc() {
  
  return groupdesc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Group::release_groupdesc() {
  // @@protoc_insertion_point(field_release:fixbug.Group.groupdesc)
  return groupdesc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Group::set_allocated_groupdesc(std::string* groupdesc) {
  if (groupdesc != nullptr) {
    
  } else {
    
  }
  groupdesc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupdesc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupdesc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupdesc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.Group.groupdesc)
}

// repeated .fixbug.User groupmember = 4;
inline int Group::_internal_groupmember_size() const {
  return groupmember_.size();
}
inline int Group::groupmember_size() const {
  return _internal_groupmember_size();
}
inline void Group::clear_groupmember() {
  groupmember_.Clear();
}
inline ::fixbug::User* Group::mutable_groupmember(int index) {
  // @@protoc_insertion_point(field_mutable:fixbug.Group.groupmember)
  return groupmember_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User >*
Group::mutable_groupmember() {
  // @@protoc_insertion_point(field_mutable_list:fixbug.Group.groupmember)
  return &groupmember_;
}
inline const ::fixbug::User& Group::_internal_groupmember(int index) const {
  return groupmember_.Get(index);
}
inline const ::fixbug::User& Group::groupmember(int index) const {
  // @@protoc_insertion_point(field_get:fixbug.Group.groupmember)
  return _internal_groupmember(index);
}
inline ::fixbug::User* Group::_internal_add_groupmember() {
  return groupmember_.Add();
}
inline ::fixbug::User* Group::add_groupmember() {
  ::fixbug::User* _add = _internal_add_groupmember();
  // @@protoc_insertion_point(field_add:fixbug.Group.groupmember)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::User >&
Group::groupmember() const {
  // @@protoc_insertion_point(field_list:fixbug.Group.groupmember)
  return groupmember_;
}

// repeated bytes memberidentity = 5;
inline int Group::_internal_memberidentity_size() const {
  return memberidentity_.size();
}
inline int Group::memberidentity_size() const {
  return _internal_memberidentity_size();
}
inline void Group::clear_memberidentity() {
  memberidentity_.Clear();
}
inline std::string* Group::add_memberidentity() {
  std::string* _s = _internal_add_memberidentity();
  // @@protoc_insertion_point(field_add_mutable:fixbug.Group.memberidentity)
  return _s;
}
inline const std::string& Group::_internal_memberidentity(int index) const {
  return memberidentity_.Get(index);
}
inline const std::string& Group::memberidentity(int index) const {
  // @@protoc_insertion_point(field_get:fixbug.Group.memberidentity)
  return _internal_memberidentity(index);
}
inline std::string* Group::mutable_memberidentity(int index) {
  // @@protoc_insertion_point(field_mutable:fixbug.Group.memberidentity)
  return memberidentity_.Mutable(index);
}
inline void Group::set_memberidentity(int index, const std::string& value) {
  memberidentity_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fixbug.Group.memberidentity)
}
inline void Group::set_memberidentity(int index, std::string&& value) {
  memberidentity_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fixbug.Group.memberidentity)
}
inline void Group::set_memberidentity(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  memberidentity_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fixbug.Group.memberidentity)
}
inline void Group::set_memberidentity(int index, const void* value, size_t size) {
  memberidentity_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fixbug.Group.memberidentity)
}
inline std::string* Group::_internal_add_memberidentity() {
  return memberidentity_.Add();
}
inline void Group::add_memberidentity(const std::string& value) {
  memberidentity_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fixbug.Group.memberidentity)
}
inline void Group::add_memberidentity(std::string&& value) {
  memberidentity_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fixbug.Group.memberidentity)
}
inline void Group::add_memberidentity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  memberidentity_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fixbug.Group.memberidentity)
}
inline void Group::add_memberidentity(const void* value, size_t size) {
  memberidentity_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fixbug.Group.memberidentity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Group::memberidentity() const {
  // @@protoc_insertion_point(field_list:fixbug.Group.memberidentity)
  return memberidentity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Group::mutable_memberidentity() {
  // @@protoc_insertion_point(field_mutable_list:fixbug.Group.memberidentity)
  return &memberidentity_;
}

// -------------------------------------------------------------------

// GroupList

// repeated .fixbug.Group group = 1;
inline int GroupList::_internal_group_size() const {
  return group_.size();
}
inline int GroupList::group_size() const {
  return _internal_group_size();
}
inline void GroupList::clear_group() {
  group_.Clear();
}
inline ::fixbug::Group* GroupList::mutable_group(int index) {
  // @@protoc_insertion_point(field_mutable:fixbug.GroupList.group)
  return group_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::Group >*
GroupList::mutable_group() {
  // @@protoc_insertion_point(field_mutable_list:fixbug.GroupList.group)
  return &group_;
}
inline const ::fixbug::Group& GroupList::_internal_group(int index) const {
  return group_.Get(index);
}
inline const ::fixbug::Group& GroupList::group(int index) const {
  // @@protoc_insertion_point(field_get:fixbug.GroupList.group)
  return _internal_group(index);
}
inline ::fixbug::Group* GroupList::_internal_add_group() {
  return group_.Add();
}
inline ::fixbug::Group* GroupList::add_group() {
  ::fixbug::Group* _add = _internal_add_group();
  // @@protoc_insertion_point(field_add:fixbug.GroupList.group)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::Group >&
GroupList::group() const {
  // @@protoc_insertion_point(field_list:fixbug.GroupList.group)
  return group_;
}

// -------------------------------------------------------------------

// ChatMessage

// bytes chattime = 1;
inline void ChatMessage::clear_chattime() {
  chattime_.ClearToEmpty();
}
inline const std::string& ChatMessage::chattime() const {
  // @@protoc_insertion_point(field_get:fixbug.ChatMessage.chattime)
  return _internal_chattime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_chattime(ArgT0&& arg0, ArgT... args) {
 
 chattime_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.ChatMessage.chattime)
}
inline std::string* ChatMessage::mutable_chattime() {
  std::string* _s = _internal_mutable_chattime();
  // @@protoc_insertion_point(field_mutable:fixbug.ChatMessage.chattime)
  return _s;
}
inline const std::string& ChatMessage::_internal_chattime() const {
  return chattime_.Get();
}
inline void ChatMessage::_internal_set_chattime(const std::string& value) {
  
  chattime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_chattime() {
  
  return chattime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMessage::release_chattime() {
  // @@protoc_insertion_point(field_release:fixbug.ChatMessage.chattime)
  return chattime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMessage::set_allocated_chattime(std::string* chattime) {
  if (chattime != nullptr) {
    
  } else {
    
  }
  chattime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chattime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chattime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chattime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.ChatMessage.chattime)
}

// bytes userid = 2;
inline void ChatMessage::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& ChatMessage::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.ChatMessage.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.ChatMessage.userid)
}
inline std::string* ChatMessage::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.ChatMessage.userid)
  return _s;
}
inline const std::string& ChatMessage::_internal_userid() const {
  return userid_.Get();
}
inline void ChatMessage::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMessage::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.ChatMessage.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMessage::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.ChatMessage.userid)
}

// bytes username = 3;
inline void ChatMessage::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& ChatMessage::username() const {
  // @@protoc_insertion_point(field_get:fixbug.ChatMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.ChatMessage.username)
}
inline std::string* ChatMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:fixbug.ChatMessage.username)
  return _s;
}
inline const std::string& ChatMessage::_internal_username() const {
  return username_.Get();
}
inline void ChatMessage::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMessage::release_username() {
  // @@protoc_insertion_point(field_release:fixbug.ChatMessage.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.ChatMessage.username)
}

// bytes groupid = 4;
inline void ChatMessage::clear_groupid() {
  groupid_.ClearToEmpty();
}
inline const std::string& ChatMessage::groupid() const {
  // @@protoc_insertion_point(field_get:fixbug.ChatMessage.groupid)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 groupid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.ChatMessage.groupid)
}
inline std::string* ChatMessage::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:fixbug.ChatMessage.groupid)
  return _s;
}
inline const std::string& ChatMessage::_internal_groupid() const {
  return groupid_.Get();
}
inline void ChatMessage::_internal_set_groupid(const std::string& value) {
  
  groupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_groupid() {
  
  return groupid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMessage::release_groupid() {
  // @@protoc_insertion_point(field_release:fixbug.ChatMessage.groupid)
  return groupid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMessage::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  groupid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.ChatMessage.groupid)
}

// bytes groupname = 5;
inline void ChatMessage::clear_groupname() {
  groupname_.ClearToEmpty();
}
inline const std::string& ChatMessage::groupname() const {
  // @@protoc_insertion_point(field_get:fixbug.ChatMessage.groupname)
  return _internal_groupname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_groupname(ArgT0&& arg0, ArgT... args) {
 
 groupname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.ChatMessage.groupname)
}
inline std::string* ChatMessage::mutable_groupname() {
  std::string* _s = _internal_mutable_groupname();
  // @@protoc_insertion_point(field_mutable:fixbug.ChatMessage.groupname)
  return _s;
}
inline const std::string& ChatMessage::_internal_groupname() const {
  return groupname_.Get();
}
inline void ChatMessage::_internal_set_groupname(const std::string& value) {
  
  groupname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_groupname() {
  
  return groupname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMessage::release_groupname() {
  // @@protoc_insertion_point(field_release:fixbug.ChatMessage.groupname)
  return groupname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMessage::set_allocated_groupname(std::string* groupname) {
  if (groupname != nullptr) {
    
  } else {
    
  }
  groupname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.ChatMessage.groupname)
}

// bytes msg = 6;
inline void ChatMessage::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& ChatMessage::msg() const {
  // @@protoc_insertion_point(field_get:fixbug.ChatMessage.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.ChatMessage.msg)
}
inline std::string* ChatMessage::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:fixbug.ChatMessage.msg)
  return _s;
}
inline const std::string& ChatMessage::_internal_msg() const {
  return msg_.Get();
}
inline void ChatMessage::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMessage::release_msg() {
  // @@protoc_insertion_point(field_release:fixbug.ChatMessage.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMessage::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.ChatMessage.msg)
}

// int32 msgtype = 7;
inline void ChatMessage::clear_msgtype() {
  msgtype_ = 0;
}
inline int32_t ChatMessage::_internal_msgtype() const {
  return msgtype_;
}
inline int32_t ChatMessage::msgtype() const {
  // @@protoc_insertion_point(field_get:fixbug.ChatMessage.msgtype)
  return _internal_msgtype();
}
inline void ChatMessage::_internal_set_msgtype(int32_t value) {
  
  msgtype_ = value;
}
inline void ChatMessage::set_msgtype(int32_t value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:fixbug.ChatMessage.msgtype)
}

// -------------------------------------------------------------------

// protobuffer

// int32 protobuftype = 1;
inline void protobuffer::clear_protobuftype() {
  protobuftype_ = 0;
}
inline int32_t protobuffer::_internal_protobuftype() const {
  return protobuftype_;
}
inline int32_t protobuffer::protobuftype() const {
  // @@protoc_insertion_point(field_get:fixbug.protobuffer.protobuftype)
  return _internal_protobuftype();
}
inline void protobuffer::_internal_set_protobuftype(int32_t value) {
  
  protobuftype_ = value;
}
inline void protobuffer::set_protobuftype(int32_t value) {
  _internal_set_protobuftype(value);
  // @@protoc_insertion_point(field_set:fixbug.protobuffer.protobuftype)
}

// bytes protobufstr = 2;
inline void protobuffer::clear_protobufstr() {
  protobufstr_.ClearToEmpty();
}
inline const std::string& protobuffer::protobufstr() const {
  // @@protoc_insertion_point(field_get:fixbug.protobuffer.protobufstr)
  return _internal_protobufstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void protobuffer::set_protobufstr(ArgT0&& arg0, ArgT... args) {
 
 protobufstr_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.protobuffer.protobufstr)
}
inline std::string* protobuffer::mutable_protobufstr() {
  std::string* _s = _internal_mutable_protobufstr();
  // @@protoc_insertion_point(field_mutable:fixbug.protobuffer.protobufstr)
  return _s;
}
inline const std::string& protobuffer::_internal_protobufstr() const {
  return protobufstr_.Get();
}
inline void protobuffer::_internal_set_protobufstr(const std::string& value) {
  
  protobufstr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* protobuffer::_internal_mutable_protobufstr() {
  
  return protobufstr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* protobuffer::release_protobufstr() {
  // @@protoc_insertion_point(field_release:fixbug.protobuffer.protobufstr)
  return protobufstr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void protobuffer::set_allocated_protobufstr(std::string* protobufstr) {
  if (protobufstr != nullptr) {
    
  } else {
    
  }
  protobufstr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protobufstr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protobufstr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    protobufstr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.protobuffer.protobufstr)
}

// -------------------------------------------------------------------

// LoginRequest

// bytes userid = 1;
inline void LoginRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& LoginRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.LoginRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.LoginRequest.userid)
}
inline std::string* LoginRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.LoginRequest.userid)
  return _s;
}
inline const std::string& LoginRequest::_internal_userid() const {
  return userid_.Get();
}
inline void LoginRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.LoginRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.LoginRequest.userid)
}

// bytes password = 2;
inline void LoginRequest::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:fixbug.LoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:fixbug.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  return password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:fixbug.LoginRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginResponse

// .fixbug.RequestResult result = 1;
inline bool LoginResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool LoginResponse::has_result() const {
  return _internal_has_result();
}
inline void LoginResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& LoginResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& LoginResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.LoginResponse.result)
  return _internal_result();
}
inline void LoginResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.LoginResponse.result)
}
inline ::fixbug::RequestResult* LoginResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* LoginResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.LoginResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* LoginResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* LoginResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.LoginResponse.result)
  return _msg;
}
inline void LoginResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.LoginResponse.result)
}

// bytes userid = 2;
inline void LoginResponse::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& LoginResponse::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.LoginResponse.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.LoginResponse.userid)
}
inline std::string* LoginResponse::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.LoginResponse.userid)
  return _s;
}
inline const std::string& LoginResponse::_internal_userid() const {
  return userid_.Get();
}
inline void LoginResponse::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginResponse::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.LoginResponse.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginResponse::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.LoginResponse.userid)
}

// bytes username = 3;
inline void LoginResponse::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& LoginResponse::username() const {
  // @@protoc_insertion_point(field_get:fixbug.LoginResponse.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.LoginResponse.username)
}
inline std::string* LoginResponse::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:fixbug.LoginResponse.username)
  return _s;
}
inline const std::string& LoginResponse::_internal_username() const {
  return username_.Get();
}
inline void LoginResponse::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginResponse::release_username() {
  // @@protoc_insertion_point(field_release:fixbug.LoginResponse.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginResponse::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.LoginResponse.username)
}

// .fixbug.FriendList friendlist = 4;
inline bool LoginResponse::_internal_has_friendlist() const {
  return this != internal_default_instance() && friendlist_ != nullptr;
}
inline bool LoginResponse::has_friendlist() const {
  return _internal_has_friendlist();
}
inline void LoginResponse::clear_friendlist() {
  if (GetArenaForAllocation() == nullptr && friendlist_ != nullptr) {
    delete friendlist_;
  }
  friendlist_ = nullptr;
}
inline const ::fixbug::FriendList& LoginResponse::_internal_friendlist() const {
  const ::fixbug::FriendList* p = friendlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::FriendList&>(
      ::fixbug::_FriendList_default_instance_);
}
inline const ::fixbug::FriendList& LoginResponse::friendlist() const {
  // @@protoc_insertion_point(field_get:fixbug.LoginResponse.friendlist)
  return _internal_friendlist();
}
inline void LoginResponse::unsafe_arena_set_allocated_friendlist(
    ::fixbug::FriendList* friendlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(friendlist_);
  }
  friendlist_ = friendlist;
  if (friendlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.LoginResponse.friendlist)
}
inline ::fixbug::FriendList* LoginResponse::release_friendlist() {
  
  ::fixbug::FriendList* temp = friendlist_;
  friendlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::FriendList* LoginResponse::unsafe_arena_release_friendlist() {
  // @@protoc_insertion_point(field_release:fixbug.LoginResponse.friendlist)
  
  ::fixbug::FriendList* temp = friendlist_;
  friendlist_ = nullptr;
  return temp;
}
inline ::fixbug::FriendList* LoginResponse::_internal_mutable_friendlist() {
  
  if (friendlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::FriendList>(GetArenaForAllocation());
    friendlist_ = p;
  }
  return friendlist_;
}
inline ::fixbug::FriendList* LoginResponse::mutable_friendlist() {
  ::fixbug::FriendList* _msg = _internal_mutable_friendlist();
  // @@protoc_insertion_point(field_mutable:fixbug.LoginResponse.friendlist)
  return _msg;
}
inline void LoginResponse::set_allocated_friendlist(::fixbug::FriendList* friendlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete friendlist_;
  }
  if (friendlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::FriendList>::GetOwningArena(friendlist);
    if (message_arena != submessage_arena) {
      friendlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friendlist, submessage_arena);
    }
    
  } else {
    
  }
  friendlist_ = friendlist;
  // @@protoc_insertion_point(field_set_allocated:fixbug.LoginResponse.friendlist)
}

// .fixbug.GroupList grouplist = 5;
inline bool LoginResponse::_internal_has_grouplist() const {
  return this != internal_default_instance() && grouplist_ != nullptr;
}
inline bool LoginResponse::has_grouplist() const {
  return _internal_has_grouplist();
}
inline void LoginResponse::clear_grouplist() {
  if (GetArenaForAllocation() == nullptr && grouplist_ != nullptr) {
    delete grouplist_;
  }
  grouplist_ = nullptr;
}
inline const ::fixbug::GroupList& LoginResponse::_internal_grouplist() const {
  const ::fixbug::GroupList* p = grouplist_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::GroupList&>(
      ::fixbug::_GroupList_default_instance_);
}
inline const ::fixbug::GroupList& LoginResponse::grouplist() const {
  // @@protoc_insertion_point(field_get:fixbug.LoginResponse.grouplist)
  return _internal_grouplist();
}
inline void LoginResponse::unsafe_arena_set_allocated_grouplist(
    ::fixbug::GroupList* grouplist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grouplist_);
  }
  grouplist_ = grouplist;
  if (grouplist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.LoginResponse.grouplist)
}
inline ::fixbug::GroupList* LoginResponse::release_grouplist() {
  
  ::fixbug::GroupList* temp = grouplist_;
  grouplist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::GroupList* LoginResponse::unsafe_arena_release_grouplist() {
  // @@protoc_insertion_point(field_release:fixbug.LoginResponse.grouplist)
  
  ::fixbug::GroupList* temp = grouplist_;
  grouplist_ = nullptr;
  return temp;
}
inline ::fixbug::GroupList* LoginResponse::_internal_mutable_grouplist() {
  
  if (grouplist_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::GroupList>(GetArenaForAllocation());
    grouplist_ = p;
  }
  return grouplist_;
}
inline ::fixbug::GroupList* LoginResponse::mutable_grouplist() {
  ::fixbug::GroupList* _msg = _internal_mutable_grouplist();
  // @@protoc_insertion_point(field_mutable:fixbug.LoginResponse.grouplist)
  return _msg;
}
inline void LoginResponse::set_allocated_grouplist(::fixbug::GroupList* grouplist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete grouplist_;
  }
  if (grouplist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::GroupList>::GetOwningArena(grouplist);
    if (message_arena != submessage_arena) {
      grouplist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grouplist, submessage_arena);
    }
    
  } else {
    
  }
  grouplist_ = grouplist;
  // @@protoc_insertion_point(field_set_allocated:fixbug.LoginResponse.grouplist)
}

// repeated .fixbug.ChatMessage offlinemsglist = 6;
inline int LoginResponse::_internal_offlinemsglist_size() const {
  return offlinemsglist_.size();
}
inline int LoginResponse::offlinemsglist_size() const {
  return _internal_offlinemsglist_size();
}
inline void LoginResponse::clear_offlinemsglist() {
  offlinemsglist_.Clear();
}
inline ::fixbug::ChatMessage* LoginResponse::mutable_offlinemsglist(int index) {
  // @@protoc_insertion_point(field_mutable:fixbug.LoginResponse.offlinemsglist)
  return offlinemsglist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage >*
LoginResponse::mutable_offlinemsglist() {
  // @@protoc_insertion_point(field_mutable_list:fixbug.LoginResponse.offlinemsglist)
  return &offlinemsglist_;
}
inline const ::fixbug::ChatMessage& LoginResponse::_internal_offlinemsglist(int index) const {
  return offlinemsglist_.Get(index);
}
inline const ::fixbug::ChatMessage& LoginResponse::offlinemsglist(int index) const {
  // @@protoc_insertion_point(field_get:fixbug.LoginResponse.offlinemsglist)
  return _internal_offlinemsglist(index);
}
inline ::fixbug::ChatMessage* LoginResponse::_internal_add_offlinemsglist() {
  return offlinemsglist_.Add();
}
inline ::fixbug::ChatMessage* LoginResponse::add_offlinemsglist() {
  ::fixbug::ChatMessage* _add = _internal_add_offlinemsglist();
  // @@protoc_insertion_point(field_add:fixbug.LoginResponse.offlinemsglist)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage >&
LoginResponse::offlinemsglist() const {
  // @@protoc_insertion_point(field_list:fixbug.LoginResponse.offlinemsglist)
  return offlinemsglist_;
}

// -------------------------------------------------------------------

// LoginoutRequest

// bytes userid = 1;
inline void LoginoutRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& LoginoutRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.LoginoutRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginoutRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.LoginoutRequest.userid)
}
inline std::string* LoginoutRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.LoginoutRequest.userid)
  return _s;
}
inline const std::string& LoginoutRequest::_internal_userid() const {
  return userid_.Get();
}
inline void LoginoutRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginoutRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginoutRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.LoginoutRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginoutRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.LoginoutRequest.userid)
}

// -------------------------------------------------------------------

// LoginoutResponse

// .fixbug.RequestResult result = 1;
inline bool LoginoutResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool LoginoutResponse::has_result() const {
  return _internal_has_result();
}
inline void LoginoutResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& LoginoutResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& LoginoutResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.LoginoutResponse.result)
  return _internal_result();
}
inline void LoginoutResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.LoginoutResponse.result)
}
inline ::fixbug::RequestResult* LoginoutResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* LoginoutResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.LoginoutResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* LoginoutResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* LoginoutResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.LoginoutResponse.result)
  return _msg;
}
inline void LoginoutResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.LoginoutResponse.result)
}

// -------------------------------------------------------------------

// RegisterRequest

// bytes username = 1;
inline void RegisterRequest::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& RegisterRequest::username() const {
  // @@protoc_insertion_point(field_get:fixbug.RegisterRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.RegisterRequest.username)
}
inline std::string* RegisterRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:fixbug.RegisterRequest.username)
  return _s;
}
inline const std::string& RegisterRequest::_internal_username() const {
  return username_.Get();
}
inline void RegisterRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_username() {
  // @@protoc_insertion_point(field_release:fixbug.RegisterRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.RegisterRequest.username)
}

// bytes password = 2;
inline void RegisterRequest::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& RegisterRequest::password() const {
  // @@protoc_insertion_point(field_get:fixbug.RegisterRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.RegisterRequest.password)
}
inline std::string* RegisterRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:fixbug.RegisterRequest.password)
  return _s;
}
inline const std::string& RegisterRequest::_internal_password() const {
  return password_.Get();
}
inline void RegisterRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_password() {
  // @@protoc_insertion_point(field_release:fixbug.RegisterRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.RegisterRequest.password)
}

// -------------------------------------------------------------------

// RegisterResponse

// .fixbug.RequestResult result = 1;
inline bool RegisterResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool RegisterResponse::has_result() const {
  return _internal_has_result();
}
inline void RegisterResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& RegisterResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& RegisterResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.RegisterResponse.result)
  return _internal_result();
}
inline void RegisterResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.RegisterResponse.result)
}
inline ::fixbug::RequestResult* RegisterResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* RegisterResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.RegisterResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* RegisterResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* RegisterResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.RegisterResponse.result)
  return _msg;
}
inline void RegisterResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.RegisterResponse.result)
}

// bytes userid = 2;
inline void RegisterResponse::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& RegisterResponse::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.RegisterResponse.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResponse::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.RegisterResponse.userid)
}
inline std::string* RegisterResponse::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.RegisterResponse.userid)
  return _s;
}
inline const std::string& RegisterResponse::_internal_userid() const {
  return userid_.Get();
}
inline void RegisterResponse::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterResponse::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterResponse::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.RegisterResponse.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterResponse::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.RegisterResponse.userid)
}

// -------------------------------------------------------------------

// GetFriendListRequest

// bytes userid = 1;
inline void GetFriendListRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& GetFriendListRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.GetFriendListRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFriendListRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.GetFriendListRequest.userid)
}
inline std::string* GetFriendListRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.GetFriendListRequest.userid)
  return _s;
}
inline const std::string& GetFriendListRequest::_internal_userid() const {
  return userid_.Get();
}
inline void GetFriendListRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFriendListRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFriendListRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.GetFriendListRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFriendListRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.GetFriendListRequest.userid)
}

// -------------------------------------------------------------------

// GetFriendListResponse

// .fixbug.RequestResult result = 1;
inline bool GetFriendListResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GetFriendListResponse::has_result() const {
  return _internal_has_result();
}
inline void GetFriendListResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& GetFriendListResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& GetFriendListResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.GetFriendListResponse.result)
  return _internal_result();
}
inline void GetFriendListResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.GetFriendListResponse.result)
}
inline ::fixbug::RequestResult* GetFriendListResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* GetFriendListResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.GetFriendListResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* GetFriendListResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* GetFriendListResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.GetFriendListResponse.result)
  return _msg;
}
inline void GetFriendListResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.GetFriendListResponse.result)
}

// .fixbug.FriendList friendlist = 2;
inline bool GetFriendListResponse::_internal_has_friendlist() const {
  return this != internal_default_instance() && friendlist_ != nullptr;
}
inline bool GetFriendListResponse::has_friendlist() const {
  return _internal_has_friendlist();
}
inline void GetFriendListResponse::clear_friendlist() {
  if (GetArenaForAllocation() == nullptr && friendlist_ != nullptr) {
    delete friendlist_;
  }
  friendlist_ = nullptr;
}
inline const ::fixbug::FriendList& GetFriendListResponse::_internal_friendlist() const {
  const ::fixbug::FriendList* p = friendlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::FriendList&>(
      ::fixbug::_FriendList_default_instance_);
}
inline const ::fixbug::FriendList& GetFriendListResponse::friendlist() const {
  // @@protoc_insertion_point(field_get:fixbug.GetFriendListResponse.friendlist)
  return _internal_friendlist();
}
inline void GetFriendListResponse::unsafe_arena_set_allocated_friendlist(
    ::fixbug::FriendList* friendlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(friendlist_);
  }
  friendlist_ = friendlist;
  if (friendlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.GetFriendListResponse.friendlist)
}
inline ::fixbug::FriendList* GetFriendListResponse::release_friendlist() {
  
  ::fixbug::FriendList* temp = friendlist_;
  friendlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::FriendList* GetFriendListResponse::unsafe_arena_release_friendlist() {
  // @@protoc_insertion_point(field_release:fixbug.GetFriendListResponse.friendlist)
  
  ::fixbug::FriendList* temp = friendlist_;
  friendlist_ = nullptr;
  return temp;
}
inline ::fixbug::FriendList* GetFriendListResponse::_internal_mutable_friendlist() {
  
  if (friendlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::FriendList>(GetArenaForAllocation());
    friendlist_ = p;
  }
  return friendlist_;
}
inline ::fixbug::FriendList* GetFriendListResponse::mutable_friendlist() {
  ::fixbug::FriendList* _msg = _internal_mutable_friendlist();
  // @@protoc_insertion_point(field_mutable:fixbug.GetFriendListResponse.friendlist)
  return _msg;
}
inline void GetFriendListResponse::set_allocated_friendlist(::fixbug::FriendList* friendlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete friendlist_;
  }
  if (friendlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::FriendList>::GetOwningArena(friendlist);
    if (message_arena != submessage_arena) {
      friendlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friendlist, submessage_arena);
    }
    
  } else {
    
  }
  friendlist_ = friendlist;
  // @@protoc_insertion_point(field_set_allocated:fixbug.GetFriendListResponse.friendlist)
}

// -------------------------------------------------------------------

// AddFriendRequest

// bytes userid = 1;
inline void AddFriendRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& AddFriendRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.AddFriendRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.AddFriendRequest.userid)
}
inline std::string* AddFriendRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.AddFriendRequest.userid)
  return _s;
}
inline const std::string& AddFriendRequest::_internal_userid() const {
  return userid_.Get();
}
inline void AddFriendRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddFriendRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddFriendRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.AddFriendRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddFriendRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.AddFriendRequest.userid)
}

// bytes friendid = 2;
inline void AddFriendRequest::clear_friendid() {
  friendid_.ClearToEmpty();
}
inline const std::string& AddFriendRequest::friendid() const {
  // @@protoc_insertion_point(field_get:fixbug.AddFriendRequest.friendid)
  return _internal_friendid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendRequest::set_friendid(ArgT0&& arg0, ArgT... args) {
 
 friendid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.AddFriendRequest.friendid)
}
inline std::string* AddFriendRequest::mutable_friendid() {
  std::string* _s = _internal_mutable_friendid();
  // @@protoc_insertion_point(field_mutable:fixbug.AddFriendRequest.friendid)
  return _s;
}
inline const std::string& AddFriendRequest::_internal_friendid() const {
  return friendid_.Get();
}
inline void AddFriendRequest::_internal_set_friendid(const std::string& value) {
  
  friendid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddFriendRequest::_internal_mutable_friendid() {
  
  return friendid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddFriendRequest::release_friendid() {
  // @@protoc_insertion_point(field_release:fixbug.AddFriendRequest.friendid)
  return friendid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddFriendRequest::set_allocated_friendid(std::string* friendid) {
  if (friendid != nullptr) {
    
  } else {
    
  }
  friendid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), friendid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (friendid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    friendid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.AddFriendRequest.friendid)
}

// -------------------------------------------------------------------

// AddFriendResponse

// .fixbug.RequestResult result = 1;
inline bool AddFriendResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool AddFriendResponse::has_result() const {
  return _internal_has_result();
}
inline void AddFriendResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& AddFriendResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& AddFriendResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.AddFriendResponse.result)
  return _internal_result();
}
inline void AddFriendResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.AddFriendResponse.result)
}
inline ::fixbug::RequestResult* AddFriendResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* AddFriendResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.AddFriendResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* AddFriendResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* AddFriendResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.AddFriendResponse.result)
  return _msg;
}
inline void AddFriendResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.AddFriendResponse.result)
}

// -------------------------------------------------------------------

// GetGroupListRequest

// bytes userid = 1;
inline void GetGroupListRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& GetGroupListRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.GetGroupListRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetGroupListRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.GetGroupListRequest.userid)
}
inline std::string* GetGroupListRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.GetGroupListRequest.userid)
  return _s;
}
inline const std::string& GetGroupListRequest::_internal_userid() const {
  return userid_.Get();
}
inline void GetGroupListRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetGroupListRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetGroupListRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.GetGroupListRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetGroupListRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.GetGroupListRequest.userid)
}

// -------------------------------------------------------------------

// GetGroupListResponse

// .fixbug.RequestResult result = 1;
inline bool GetGroupListResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GetGroupListResponse::has_result() const {
  return _internal_has_result();
}
inline void GetGroupListResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& GetGroupListResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& GetGroupListResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.GetGroupListResponse.result)
  return _internal_result();
}
inline void GetGroupListResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.GetGroupListResponse.result)
}
inline ::fixbug::RequestResult* GetGroupListResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* GetGroupListResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.GetGroupListResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* GetGroupListResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* GetGroupListResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.GetGroupListResponse.result)
  return _msg;
}
inline void GetGroupListResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.GetGroupListResponse.result)
}

// .fixbug.GroupList grouplist = 2;
inline bool GetGroupListResponse::_internal_has_grouplist() const {
  return this != internal_default_instance() && grouplist_ != nullptr;
}
inline bool GetGroupListResponse::has_grouplist() const {
  return _internal_has_grouplist();
}
inline void GetGroupListResponse::clear_grouplist() {
  if (GetArenaForAllocation() == nullptr && grouplist_ != nullptr) {
    delete grouplist_;
  }
  grouplist_ = nullptr;
}
inline const ::fixbug::GroupList& GetGroupListResponse::_internal_grouplist() const {
  const ::fixbug::GroupList* p = grouplist_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::GroupList&>(
      ::fixbug::_GroupList_default_instance_);
}
inline const ::fixbug::GroupList& GetGroupListResponse::grouplist() const {
  // @@protoc_insertion_point(field_get:fixbug.GetGroupListResponse.grouplist)
  return _internal_grouplist();
}
inline void GetGroupListResponse::unsafe_arena_set_allocated_grouplist(
    ::fixbug::GroupList* grouplist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grouplist_);
  }
  grouplist_ = grouplist;
  if (grouplist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.GetGroupListResponse.grouplist)
}
inline ::fixbug::GroupList* GetGroupListResponse::release_grouplist() {
  
  ::fixbug::GroupList* temp = grouplist_;
  grouplist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::GroupList* GetGroupListResponse::unsafe_arena_release_grouplist() {
  // @@protoc_insertion_point(field_release:fixbug.GetGroupListResponse.grouplist)
  
  ::fixbug::GroupList* temp = grouplist_;
  grouplist_ = nullptr;
  return temp;
}
inline ::fixbug::GroupList* GetGroupListResponse::_internal_mutable_grouplist() {
  
  if (grouplist_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::GroupList>(GetArenaForAllocation());
    grouplist_ = p;
  }
  return grouplist_;
}
inline ::fixbug::GroupList* GetGroupListResponse::mutable_grouplist() {
  ::fixbug::GroupList* _msg = _internal_mutable_grouplist();
  // @@protoc_insertion_point(field_mutable:fixbug.GetGroupListResponse.grouplist)
  return _msg;
}
inline void GetGroupListResponse::set_allocated_grouplist(::fixbug::GroupList* grouplist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete grouplist_;
  }
  if (grouplist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::GroupList>::GetOwningArena(grouplist);
    if (message_arena != submessage_arena) {
      grouplist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grouplist, submessage_arena);
    }
    
  } else {
    
  }
  grouplist_ = grouplist;
  // @@protoc_insertion_point(field_set_allocated:fixbug.GetGroupListResponse.grouplist)
}

// -------------------------------------------------------------------

// CreateGroupRequest

// bytes userid = 1;
inline void CreateGroupRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& CreateGroupRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.CreateGroupRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGroupRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.CreateGroupRequest.userid)
}
inline std::string* CreateGroupRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.CreateGroupRequest.userid)
  return _s;
}
inline const std::string& CreateGroupRequest::_internal_userid() const {
  return userid_.Get();
}
inline void CreateGroupRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.CreateGroupRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateGroupRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.CreateGroupRequest.userid)
}

// bytes groupname = 2;
inline void CreateGroupRequest::clear_groupname() {
  groupname_.ClearToEmpty();
}
inline const std::string& CreateGroupRequest::groupname() const {
  // @@protoc_insertion_point(field_get:fixbug.CreateGroupRequest.groupname)
  return _internal_groupname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGroupRequest::set_groupname(ArgT0&& arg0, ArgT... args) {
 
 groupname_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.CreateGroupRequest.groupname)
}
inline std::string* CreateGroupRequest::mutable_groupname() {
  std::string* _s = _internal_mutable_groupname();
  // @@protoc_insertion_point(field_mutable:fixbug.CreateGroupRequest.groupname)
  return _s;
}
inline const std::string& CreateGroupRequest::_internal_groupname() const {
  return groupname_.Get();
}
inline void CreateGroupRequest::_internal_set_groupname(const std::string& value) {
  
  groupname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::_internal_mutable_groupname() {
  
  return groupname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::release_groupname() {
  // @@protoc_insertion_point(field_release:fixbug.CreateGroupRequest.groupname)
  return groupname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateGroupRequest::set_allocated_groupname(std::string* groupname) {
  if (groupname != nullptr) {
    
  } else {
    
  }
  groupname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.CreateGroupRequest.groupname)
}

// bytes groupdesc = 3;
inline void CreateGroupRequest::clear_groupdesc() {
  groupdesc_.ClearToEmpty();
}
inline const std::string& CreateGroupRequest::groupdesc() const {
  // @@protoc_insertion_point(field_get:fixbug.CreateGroupRequest.groupdesc)
  return _internal_groupdesc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGroupRequest::set_groupdesc(ArgT0&& arg0, ArgT... args) {
 
 groupdesc_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.CreateGroupRequest.groupdesc)
}
inline std::string* CreateGroupRequest::mutable_groupdesc() {
  std::string* _s = _internal_mutable_groupdesc();
  // @@protoc_insertion_point(field_mutable:fixbug.CreateGroupRequest.groupdesc)
  return _s;
}
inline const std::string& CreateGroupRequest::_internal_groupdesc() const {
  return groupdesc_.Get();
}
inline void CreateGroupRequest::_internal_set_groupdesc(const std::string& value) {
  
  groupdesc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::_internal_mutable_groupdesc() {
  
  return groupdesc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::release_groupdesc() {
  // @@protoc_insertion_point(field_release:fixbug.CreateGroupRequest.groupdesc)
  return groupdesc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateGroupRequest::set_allocated_groupdesc(std::string* groupdesc) {
  if (groupdesc != nullptr) {
    
  } else {
    
  }
  groupdesc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupdesc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupdesc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupdesc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.CreateGroupRequest.groupdesc)
}

// -------------------------------------------------------------------

// CreateGroupResponse

// .fixbug.RequestResult result = 1;
inline bool CreateGroupResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool CreateGroupResponse::has_result() const {
  return _internal_has_result();
}
inline void CreateGroupResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& CreateGroupResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& CreateGroupResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.CreateGroupResponse.result)
  return _internal_result();
}
inline void CreateGroupResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.CreateGroupResponse.result)
}
inline ::fixbug::RequestResult* CreateGroupResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* CreateGroupResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.CreateGroupResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* CreateGroupResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* CreateGroupResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.CreateGroupResponse.result)
  return _msg;
}
inline void CreateGroupResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.CreateGroupResponse.result)
}

// bytes groupid = 2;
inline void CreateGroupResponse::clear_groupid() {
  groupid_.ClearToEmpty();
}
inline const std::string& CreateGroupResponse::groupid() const {
  // @@protoc_insertion_point(field_get:fixbug.CreateGroupResponse.groupid)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGroupResponse::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 groupid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.CreateGroupResponse.groupid)
}
inline std::string* CreateGroupResponse::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:fixbug.CreateGroupResponse.groupid)
  return _s;
}
inline const std::string& CreateGroupResponse::_internal_groupid() const {
  return groupid_.Get();
}
inline void CreateGroupResponse::_internal_set_groupid(const std::string& value) {
  
  groupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateGroupResponse::_internal_mutable_groupid() {
  
  return groupid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateGroupResponse::release_groupid() {
  // @@protoc_insertion_point(field_release:fixbug.CreateGroupResponse.groupid)
  return groupid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateGroupResponse::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  groupid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.CreateGroupResponse.groupid)
}

// -------------------------------------------------------------------

// AddGroupRequest

// bytes userid = 1;
inline void AddGroupRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& AddGroupRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.AddGroupRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddGroupRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.AddGroupRequest.userid)
}
inline std::string* AddGroupRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.AddGroupRequest.userid)
  return _s;
}
inline const std::string& AddGroupRequest::_internal_userid() const {
  return userid_.Get();
}
inline void AddGroupRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddGroupRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddGroupRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.AddGroupRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddGroupRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.AddGroupRequest.userid)
}

// bytes groupid = 2;
inline void AddGroupRequest::clear_groupid() {
  groupid_.ClearToEmpty();
}
inline const std::string& AddGroupRequest::groupid() const {
  // @@protoc_insertion_point(field_get:fixbug.AddGroupRequest.groupid)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddGroupRequest::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 groupid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.AddGroupRequest.groupid)
}
inline std::string* AddGroupRequest::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:fixbug.AddGroupRequest.groupid)
  return _s;
}
inline const std::string& AddGroupRequest::_internal_groupid() const {
  return groupid_.Get();
}
inline void AddGroupRequest::_internal_set_groupid(const std::string& value) {
  
  groupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddGroupRequest::_internal_mutable_groupid() {
  
  return groupid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddGroupRequest::release_groupid() {
  // @@protoc_insertion_point(field_release:fixbug.AddGroupRequest.groupid)
  return groupid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddGroupRequest::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  groupid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.AddGroupRequest.groupid)
}

// -------------------------------------------------------------------

// AddGroupResponse

// .fixbug.RequestResult result = 1;
inline bool AddGroupResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool AddGroupResponse::has_result() const {
  return _internal_has_result();
}
inline void AddGroupResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& AddGroupResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& AddGroupResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.AddGroupResponse.result)
  return _internal_result();
}
inline void AddGroupResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.AddGroupResponse.result)
}
inline ::fixbug::RequestResult* AddGroupResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* AddGroupResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.AddGroupResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* AddGroupResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* AddGroupResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.AddGroupResponse.result)
  return _msg;
}
inline void AddGroupResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.AddGroupResponse.result)
}

// -------------------------------------------------------------------

// OneChatRequest

// bytes userid = 1;
inline void OneChatRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& OneChatRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.OneChatRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OneChatRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.OneChatRequest.userid)
}
inline std::string* OneChatRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.OneChatRequest.userid)
  return _s;
}
inline const std::string& OneChatRequest::_internal_userid() const {
  return userid_.Get();
}
inline void OneChatRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OneChatRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OneChatRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.OneChatRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OneChatRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.OneChatRequest.userid)
}

// bytes friendid = 2;
inline void OneChatRequest::clear_friendid() {
  friendid_.ClearToEmpty();
}
inline const std::string& OneChatRequest::friendid() const {
  // @@protoc_insertion_point(field_get:fixbug.OneChatRequest.friendid)
  return _internal_friendid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OneChatRequest::set_friendid(ArgT0&& arg0, ArgT... args) {
 
 friendid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.OneChatRequest.friendid)
}
inline std::string* OneChatRequest::mutable_friendid() {
  std::string* _s = _internal_mutable_friendid();
  // @@protoc_insertion_point(field_mutable:fixbug.OneChatRequest.friendid)
  return _s;
}
inline const std::string& OneChatRequest::_internal_friendid() const {
  return friendid_.Get();
}
inline void OneChatRequest::_internal_set_friendid(const std::string& value) {
  
  friendid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OneChatRequest::_internal_mutable_friendid() {
  
  return friendid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OneChatRequest::release_friendid() {
  // @@protoc_insertion_point(field_release:fixbug.OneChatRequest.friendid)
  return friendid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OneChatRequest::set_allocated_friendid(std::string* friendid) {
  if (friendid != nullptr) {
    
  } else {
    
  }
  friendid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), friendid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (friendid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    friendid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.OneChatRequest.friendid)
}

// .fixbug.ChatMessage chatmsg = 3;
inline bool OneChatRequest::_internal_has_chatmsg() const {
  return this != internal_default_instance() && chatmsg_ != nullptr;
}
inline bool OneChatRequest::has_chatmsg() const {
  return _internal_has_chatmsg();
}
inline void OneChatRequest::clear_chatmsg() {
  if (GetArenaForAllocation() == nullptr && chatmsg_ != nullptr) {
    delete chatmsg_;
  }
  chatmsg_ = nullptr;
}
inline const ::fixbug::ChatMessage& OneChatRequest::_internal_chatmsg() const {
  const ::fixbug::ChatMessage* p = chatmsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::ChatMessage&>(
      ::fixbug::_ChatMessage_default_instance_);
}
inline const ::fixbug::ChatMessage& OneChatRequest::chatmsg() const {
  // @@protoc_insertion_point(field_get:fixbug.OneChatRequest.chatmsg)
  return _internal_chatmsg();
}
inline void OneChatRequest::unsafe_arena_set_allocated_chatmsg(
    ::fixbug::ChatMessage* chatmsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chatmsg_);
  }
  chatmsg_ = chatmsg;
  if (chatmsg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.OneChatRequest.chatmsg)
}
inline ::fixbug::ChatMessage* OneChatRequest::release_chatmsg() {
  
  ::fixbug::ChatMessage* temp = chatmsg_;
  chatmsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::ChatMessage* OneChatRequest::unsafe_arena_release_chatmsg() {
  // @@protoc_insertion_point(field_release:fixbug.OneChatRequest.chatmsg)
  
  ::fixbug::ChatMessage* temp = chatmsg_;
  chatmsg_ = nullptr;
  return temp;
}
inline ::fixbug::ChatMessage* OneChatRequest::_internal_mutable_chatmsg() {
  
  if (chatmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::ChatMessage>(GetArenaForAllocation());
    chatmsg_ = p;
  }
  return chatmsg_;
}
inline ::fixbug::ChatMessage* OneChatRequest::mutable_chatmsg() {
  ::fixbug::ChatMessage* _msg = _internal_mutable_chatmsg();
  // @@protoc_insertion_point(field_mutable:fixbug.OneChatRequest.chatmsg)
  return _msg;
}
inline void OneChatRequest::set_allocated_chatmsg(::fixbug::ChatMessage* chatmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chatmsg_;
  }
  if (chatmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::ChatMessage>::GetOwningArena(chatmsg);
    if (message_arena != submessage_arena) {
      chatmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatmsg, submessage_arena);
    }
    
  } else {
    
  }
  chatmsg_ = chatmsg;
  // @@protoc_insertion_point(field_set_allocated:fixbug.OneChatRequest.chatmsg)
}

// -------------------------------------------------------------------

// OneChatResponse

// .fixbug.RequestResult result = 1;
inline bool OneChatResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool OneChatResponse::has_result() const {
  return _internal_has_result();
}
inline void OneChatResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& OneChatResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& OneChatResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.OneChatResponse.result)
  return _internal_result();
}
inline void OneChatResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.OneChatResponse.result)
}
inline ::fixbug::RequestResult* OneChatResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* OneChatResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.OneChatResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* OneChatResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* OneChatResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.OneChatResponse.result)
  return _msg;
}
inline void OneChatResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.OneChatResponse.result)
}

// -------------------------------------------------------------------

// GroupChatRequest

// bytes userid = 1;
inline void GroupChatRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& GroupChatRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.GroupChatRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChatRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.GroupChatRequest.userid)
}
inline std::string* GroupChatRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.GroupChatRequest.userid)
  return _s;
}
inline const std::string& GroupChatRequest::_internal_userid() const {
  return userid_.Get();
}
inline void GroupChatRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GroupChatRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GroupChatRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.GroupChatRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GroupChatRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.GroupChatRequest.userid)
}

// bytes groupid = 2;
inline void GroupChatRequest::clear_groupid() {
  groupid_.ClearToEmpty();
}
inline const std::string& GroupChatRequest::groupid() const {
  // @@protoc_insertion_point(field_get:fixbug.GroupChatRequest.groupid)
  return _internal_groupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChatRequest::set_groupid(ArgT0&& arg0, ArgT... args) {
 
 groupid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.GroupChatRequest.groupid)
}
inline std::string* GroupChatRequest::mutable_groupid() {
  std::string* _s = _internal_mutable_groupid();
  // @@protoc_insertion_point(field_mutable:fixbug.GroupChatRequest.groupid)
  return _s;
}
inline const std::string& GroupChatRequest::_internal_groupid() const {
  return groupid_.Get();
}
inline void GroupChatRequest::_internal_set_groupid(const std::string& value) {
  
  groupid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GroupChatRequest::_internal_mutable_groupid() {
  
  return groupid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GroupChatRequest::release_groupid() {
  // @@protoc_insertion_point(field_release:fixbug.GroupChatRequest.groupid)
  return groupid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GroupChatRequest::set_allocated_groupid(std::string* groupid) {
  if (groupid != nullptr) {
    
  } else {
    
  }
  groupid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), groupid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (groupid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    groupid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.GroupChatRequest.groupid)
}

// .fixbug.ChatMessage chatmsg = 3;
inline bool GroupChatRequest::_internal_has_chatmsg() const {
  return this != internal_default_instance() && chatmsg_ != nullptr;
}
inline bool GroupChatRequest::has_chatmsg() const {
  return _internal_has_chatmsg();
}
inline void GroupChatRequest::clear_chatmsg() {
  if (GetArenaForAllocation() == nullptr && chatmsg_ != nullptr) {
    delete chatmsg_;
  }
  chatmsg_ = nullptr;
}
inline const ::fixbug::ChatMessage& GroupChatRequest::_internal_chatmsg() const {
  const ::fixbug::ChatMessage* p = chatmsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::ChatMessage&>(
      ::fixbug::_ChatMessage_default_instance_);
}
inline const ::fixbug::ChatMessage& GroupChatRequest::chatmsg() const {
  // @@protoc_insertion_point(field_get:fixbug.GroupChatRequest.chatmsg)
  return _internal_chatmsg();
}
inline void GroupChatRequest::unsafe_arena_set_allocated_chatmsg(
    ::fixbug::ChatMessage* chatmsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chatmsg_);
  }
  chatmsg_ = chatmsg;
  if (chatmsg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.GroupChatRequest.chatmsg)
}
inline ::fixbug::ChatMessage* GroupChatRequest::release_chatmsg() {
  
  ::fixbug::ChatMessage* temp = chatmsg_;
  chatmsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::ChatMessage* GroupChatRequest::unsafe_arena_release_chatmsg() {
  // @@protoc_insertion_point(field_release:fixbug.GroupChatRequest.chatmsg)
  
  ::fixbug::ChatMessage* temp = chatmsg_;
  chatmsg_ = nullptr;
  return temp;
}
inline ::fixbug::ChatMessage* GroupChatRequest::_internal_mutable_chatmsg() {
  
  if (chatmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::ChatMessage>(GetArenaForAllocation());
    chatmsg_ = p;
  }
  return chatmsg_;
}
inline ::fixbug::ChatMessage* GroupChatRequest::mutable_chatmsg() {
  ::fixbug::ChatMessage* _msg = _internal_mutable_chatmsg();
  // @@protoc_insertion_point(field_mutable:fixbug.GroupChatRequest.chatmsg)
  return _msg;
}
inline void GroupChatRequest::set_allocated_chatmsg(::fixbug::ChatMessage* chatmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chatmsg_;
  }
  if (chatmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::ChatMessage>::GetOwningArena(chatmsg);
    if (message_arena != submessage_arena) {
      chatmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatmsg, submessage_arena);
    }
    
  } else {
    
  }
  chatmsg_ = chatmsg;
  // @@protoc_insertion_point(field_set_allocated:fixbug.GroupChatRequest.chatmsg)
}

// -------------------------------------------------------------------

// GroupChatResponse

// .fixbug.RequestResult result = 1;
inline bool GroupChatResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GroupChatResponse::has_result() const {
  return _internal_has_result();
}
inline void GroupChatResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& GroupChatResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& GroupChatResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.GroupChatResponse.result)
  return _internal_result();
}
inline void GroupChatResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.GroupChatResponse.result)
}
inline ::fixbug::RequestResult* GroupChatResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* GroupChatResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.GroupChatResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* GroupChatResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* GroupChatResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.GroupChatResponse.result)
  return _msg;
}
inline void GroupChatResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.GroupChatResponse.result)
}

// -------------------------------------------------------------------

// GetOfflineMsgRequest

// bytes userid = 1;
inline void GetOfflineMsgRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& GetOfflineMsgRequest::userid() const {
  // @@protoc_insertion_point(field_get:fixbug.GetOfflineMsgRequest.userid)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetOfflineMsgRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fixbug.GetOfflineMsgRequest.userid)
}
inline std::string* GetOfflineMsgRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:fixbug.GetOfflineMsgRequest.userid)
  return _s;
}
inline const std::string& GetOfflineMsgRequest::_internal_userid() const {
  return userid_.Get();
}
inline void GetOfflineMsgRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetOfflineMsgRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetOfflineMsgRequest::release_userid() {
  // @@protoc_insertion_point(field_release:fixbug.GetOfflineMsgRequest.userid)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetOfflineMsgRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fixbug.GetOfflineMsgRequest.userid)
}

// -------------------------------------------------------------------

// GetOfflineMsgResponse

// .fixbug.RequestResult result = 1;
inline bool GetOfflineMsgResponse::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool GetOfflineMsgResponse::has_result() const {
  return _internal_has_result();
}
inline void GetOfflineMsgResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::fixbug::RequestResult& GetOfflineMsgResponse::_internal_result() const {
  const ::fixbug::RequestResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::fixbug::RequestResult&>(
      ::fixbug::_RequestResult_default_instance_);
}
inline const ::fixbug::RequestResult& GetOfflineMsgResponse::result() const {
  // @@protoc_insertion_point(field_get:fixbug.GetOfflineMsgResponse.result)
  return _internal_result();
}
inline void GetOfflineMsgResponse::unsafe_arena_set_allocated_result(
    ::fixbug::RequestResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fixbug.GetOfflineMsgResponse.result)
}
inline ::fixbug::RequestResult* GetOfflineMsgResponse::release_result() {
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fixbug::RequestResult* GetOfflineMsgResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:fixbug.GetOfflineMsgResponse.result)
  
  ::fixbug::RequestResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::fixbug::RequestResult* GetOfflineMsgResponse::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fixbug::RequestResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::fixbug::RequestResult* GetOfflineMsgResponse::mutable_result() {
  ::fixbug::RequestResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:fixbug.GetOfflineMsgResponse.result)
  return _msg;
}
inline void GetOfflineMsgResponse::set_allocated_result(::fixbug::RequestResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::fixbug::RequestResult>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:fixbug.GetOfflineMsgResponse.result)
}

// repeated .fixbug.ChatMessage offlinemsglist = 2;
inline int GetOfflineMsgResponse::_internal_offlinemsglist_size() const {
  return offlinemsglist_.size();
}
inline int GetOfflineMsgResponse::offlinemsglist_size() const {
  return _internal_offlinemsglist_size();
}
inline void GetOfflineMsgResponse::clear_offlinemsglist() {
  offlinemsglist_.Clear();
}
inline ::fixbug::ChatMessage* GetOfflineMsgResponse::mutable_offlinemsglist(int index) {
  // @@protoc_insertion_point(field_mutable:fixbug.GetOfflineMsgResponse.offlinemsglist)
  return offlinemsglist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage >*
GetOfflineMsgResponse::mutable_offlinemsglist() {
  // @@protoc_insertion_point(field_mutable_list:fixbug.GetOfflineMsgResponse.offlinemsglist)
  return &offlinemsglist_;
}
inline const ::fixbug::ChatMessage& GetOfflineMsgResponse::_internal_offlinemsglist(int index) const {
  return offlinemsglist_.Get(index);
}
inline const ::fixbug::ChatMessage& GetOfflineMsgResponse::offlinemsglist(int index) const {
  // @@protoc_insertion_point(field_get:fixbug.GetOfflineMsgResponse.offlinemsglist)
  return _internal_offlinemsglist(index);
}
inline ::fixbug::ChatMessage* GetOfflineMsgResponse::_internal_add_offlinemsglist() {
  return offlinemsglist_.Add();
}
inline ::fixbug::ChatMessage* GetOfflineMsgResponse::add_offlinemsglist() {
  ::fixbug::ChatMessage* _add = _internal_add_offlinemsglist();
  // @@protoc_insertion_point(field_add:fixbug.GetOfflineMsgResponse.offlinemsglist)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fixbug::ChatMessage >&
GetOfflineMsgResponse::offlinemsglist() const {
  // @@protoc_insertion_point(field_list:fixbug.GetOfflineMsgResponse.offlinemsglist)
  return offlinemsglist_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fixbug

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_qq_2eproto
